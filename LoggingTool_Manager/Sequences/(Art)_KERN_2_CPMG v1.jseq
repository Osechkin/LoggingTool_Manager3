// [Main]

// Описание: Стандартная активация T2, Двойная активация, Активация глин, Активация солид
// Назначение: Активация позволяет получать релаксационный спад (эхо-сигнала) при таком времени ожидания (time waiting) Tw, что пластовые флюиды полностью поляризованы,
// и минимальном интервале между эхо (time between echo) Te=2*tau, при котором сводятся к минимумам эффекты диффузии на амплитуду спинового эхо.
// Посмледовательность: [[Aq(noise)]a]n-Tw1-90-tau-180-cpmg1_tau-Aq(echo)-tau-[180-cpmg1_tau-Aq(echo)-tau]a]i-90-t1-90-t2-90-t3-90-t4-90-t5-90-t6-90-Tw2-Send
// Ядро преобразования: Kij=exp(-ti/T2j) 
// Первичная цифровая обработка сигналов:
// - сигналы шума и сигналы спинового эхо измеряются;
// - вычисляются мощностные спектры шума и спиновых эхо;
// - с учётом усреднённого мощностного спектра шума вычисляются амплитуды полезного сигнала спинового эхо
// Контроль обработки данных:
// - сигнал с оконнной функцией
// - амплитудный спектр мощности спектров сигнала и шума
// Вывод данных:
// - амплитуды спинового эхо в последовательности КПМГ

main.name = "2 CPMG with 1 Clay CPMG v.1"
main.author = "КФУ: Скирда В.Д., Александров А.А., Савинков А.В, Дорогиницкий М.М."
main.datetime = "10.10.2017 11:50"
main.description = "Стандартная активация T2, Двойная активация, Активация глин, Активация солид"


// Блок констант
// [Constants]
	var DDS_CLK_FRQ = 250000 													// Тактовая частота DDS (кГц) (константа, прошита в ПЛИС)
	var IF_FRQ = 1250															// Промежуточная частота приемника (кГц) (константа, задана аппаратно)
	var NMR_SAMPLE_FREQ = 5000													// Частота дискретизации (кГц) (константа, задана аппаратно)

//-----------------------------------------------------------------------------------------------------------
// Блок параметров датчиков
// [Probes]

	@parameter cpmg_channel = { "КПМГ1.  Номер канала", 1, min=1, max=1 }
	cpmg_channel.comment = "выбор номера канала измерений (0 - первый канал ЯМР, 1 - второй канал ЯМР, ...)"
	cpmg_channel.exec(cpmg_channel~ - 1)
	
	@parameter KU = { "Усиление приемника", -10, min=-24, max=0, units="дБ"}
	KU.comment = "Коэффициент усиления приемника"
	KU.exec(- KU~)
	
	@section s_probes = { "Probes" }
	//s_probes.append(cpmg_channel)
	s_probes.append(KU)

//-----------------------------------------------------------------------------------------------------------
// Блок параметров частот
// [Frequencies]

	@parameter cpmg_frq_ofs = { "Канал 1.  Частота резонанса", 0, min=-488, max=488, units="кГц" }
	cpmg_frq_ofs.comment = "Смещение частоты относительно заданной базовой частоты"
	cpmg_frq_ofs.exec(cpmg_frq_ofs~ * 4294967296 / DDS_CLK_FRQ)
	
	@parameter tx_frq2_ofs = { "Канал 1. Опорная частота передачи", 0, min=-488, max=488, units="кГц" }
	tx_frq2_ofs.comment = "Смещение опорной частоты передачи относительно заданной базовой частоты"
	tx_frq2_ofs.exec(tx_frq2_ofs~ / DDS_CLK_FRQ * 4294967296)
	
	// Смещение частоты оцифровки относительно заданной базовой
	var adc_frq_ofs = 0;
	adc_frq_ofs = adc_frq_ofs / DDS_CLK_FRQ * 4294967296;						// Частота АЦП
	
	@parameter vc_dac = { "Канал 1.  Настройка антенны", 2000, min=0, max=5000, units="мВ" }
	vc_dac.comment = "Напряжение на варикапах, мВ"
	vc_dac.exec(vc_dac~ * 65535 / 5000)
	
	@section s_freqs = { "Frequencies" }
	s_freqs.append(cpmg_frq_ofs)
	s_freqs.append(vc_dac)

//-----------------------------------------------------------------------------------------------------------
// Блок длительности РЧ-импульсов
// [RF_pulses]

	@parameter cpmg_rfp_90 = { "Канал 1.  90<sup>0</sup> импульс", 13, min=0, max=1000, units="мкс" }
	cpmg_rfp_90.comment = "Длительность 90<sup>0</sup> РЧ импульса"
	cpmg_rfp_90.exec(cpmg_rfp_90~ * 10)																	// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	
	@parameter cpmg_rfp_180 = { "Канал 1.  180<sup>0</sup> импульс", 26, min=0, max=1000, units="мкс" }
	cpmg_rfp_180.comment = "Длительность 180<sup>0</sup> РЧ импульса"
	cpmg_rfp_180.exec(cpmg_rfp_180~ * 10)																// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	
	@section s_rf_pulses = { "RF-Pulses" }
	s_rf_pulses.append(cpmg_rfp_90)
	s_rf_pulses.append(cpmg_rfp_180)

//-----------------------------------------------------------------------------------------------------------
// Блок настройки фаз импульсов
// [Phases]

	@parameter ph_90 = { "90<sup>0</sup> импульс. Фаза", 0, min=0, max=360, units=" <sup>0</sup>, град." }
	ph_90.comment = "90<sup>0</sup> импульс. Фаза"
	ph_90.exec(ph_90~ * 46603.375)
	
	@parameter ph_180 = { "180<sup>0</sup> импульс. Фаза", 90, min=0, max=360, units=" <sup>0</sup>, град." }
	ph_180.comment = "180<sup>0</sup> импульс. Фаза"
	ph_180.exec(ph_180~ * 46603.375)
	
	// Инкремент фазы. Значение инкремента фазы для фазового циклирования
	var dph = 180
	dph = dph * 46603.375; 																				// "град."
	
	@section s_phases = { "Phases" }
	s_phases.append(ph_90)
	s_phases.append(ph_180)

//-----------------------------------------------------------------------------------------------------------
// Блок счетчиков
// [Counters]

	@parameter noise_group = { "КПМГ(1,2). Окон шума", 32, min=1, max=64 }
	noise_group.comment = "Число окон АЦП для измерения шума"
	
	@parameter echoes_group = { "КПМГ(1,2). Окон эхо", 1, min=1, max=500 }
	echoes_group.comment = "Число окон АЦП для измерения сигналов спинового эхо"
	
	@parameter echoes_accum = { "КПМГ(1,2). Накоплений", 1, min=1, max=16 }
	echoes_accum.comment = "Число повторения последовательности КПМГ для накопления сигнала и шума"
	
	@parameter echoes_clay = { "Канал глин. Окон эхо", 20, min=1, max=300 }
	echoes_clay.comment = "Число групп окон АЦП для измерения сигналов спинового эхо"
	
	@parameter accum_clay = { "Канал глин. Накоплений", 2, min=1, max=4 }
	accum_clay.comment = "Число фазовых циклов"
	accum_clay.exec(2 * accum_clay~)
	
	@section s_counters = { "Counters" }
	s_counters.append(noise_group)
	s_counters.append(echoes_group)
	s_counters.append(echoes_accum)
	s_counters.append(echoes_clay)

//-----------------------------------------------------------------------------------------------------------
// Блок временных параметров последовательности
// [Intervals]

	@parameter to_relax = { "КПМГ1. TW(Время отдыха)", 1000, min=1, max=16777, units="мс" }
	to_relax.comment = "Время на восстановление намагниченности после измеренийГ"
	
	@parameter to_cpmg2 = { "КПМГ2. TW2(Время насыщения)", 50, min=50, max=16777, units="мс" }
	to_cpmg2.comment = "Время на восстановление намагниченности после КПМГ1"
	to_cpmg2.exec(to_cpmg2~ * 1000 - 1)																	// *1000 для перевода мс в мкс, минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_clay = { "Канал глин. TW", 20, min=10, max=16777, units="мс" }
	to_clay.comment = "Время на восстановление намагниченности глин"
	to_clay.exec(to_clay~ * 1000 - 1)																	// *1000 для перевода мс в мкс, минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter cpmg1_tau = { "КПМГ1. TAU", 500, min=400, max=16777, units="мкс" }
	cpmg1_tau.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ1"
	
	@parameter cpmg2_tau = { "КПМГ2. TAU", 500, min=400, max=16777, units="мкс" }
	cpmg2_tau.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ2"
	
	@parameter clay_tau = { "Канал глин. TAU", 400, min=500, max=16777, units="мкс" }
	clay_tau.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности CLAY КПМГ "
	
	@parameter to_aq_shift = { "Смещение окна АЦП", 20, min=1, max=16777, units="мкс" }
	to_aq_shift.comment = "Смещение окна АЦП от расчетного времени в последовательности КПМГ"
	to_aq_shift.exec(to_aq_shift~ - 1)																	// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_echo_aq = { "КПМГ(1,2). Окно АЦП", 150, min=1, max=16777, units="мкс" }
	to_echo_aq.comment = "Длительность окна АЦП для регистрации сигнала спинового эхо в последовательности КПМГ"
	to_echo_aq.exec(to_echo_aq~ - 1)																	// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@section s_delays = { "Intervals" }
	s_delays.append(to_relax)
	s_delays.append(to_cpmg2)
	s_delays.append(to_clay)
	s_delays.append(cpmg1_tau)
	s_delays.append(cpmg2_tau)
	s_delays.append(clay_tau)
	s_delays.append(to_aq_shift)
	s_delays.append(to_echo_aq)
	
	@parameter to_aq_start = { "Опережение отключения БП", 1, min=1, max=16777, units="мкс" }
	to_aq_start.comment = "Время опережения отключения БП окна АЦП, мкс"
	to_aq_start.exec(to_aq_start~ - 1)																	// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	// Задержка перед АЦП последовательности КПМГ1
	var to_cpmg1_blank_pulse = cpmg1_tau~ + to_aq_shift~ - (to_aq_start~ + to_echo_aq~ / 2)				// Задержка перед АЦП в КПМГ1, мкс
	to_cpmg1_blank_pulse -= 1																			// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	// Задержка перед АЦП последовательности КПМГ2
	var to_cpmg2_blank_pulse = cpmg2_tau~ + to_aq_shift~ - (to_aq_start~ + to_echo_aq~ / 2)				// Задержка перед АЦП в КПМГ2, мкс
	to_cpmg2_blank_pulse -= 1																			// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	// Задержка перед АЦП последовательности CLAY КПМГ
	var to_clay_blank_pulse = clay_tau~ + to_aq_shift~ - (to_aq_start~ + to_echo_aq~ / 2)				// Задержка перед АЦП в CLAY КПМГ, мкс
	to_clay_blank_pulse -= 1																			// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	// "Задержка перед 180<sup>0</sup> импульсом КПМГ1"
	var to_next_cp1_180 = cpmg1_tau~ - to_aq_shift~ - (to_echo_aq~ / 2)									// Задержка перед 180<sup>0</sup> импульсом КПМГ1, мкс
	to_next_cp1_180 -= 1																				// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	// "Задержка перед 180<sup>0</sup> импульсом КПМГ2"
	var to_next_cp2_180 = cpmg2_tau~ - to_aq_shift~ - (to_echo_aq~ / 2)									// Задержка перед 180<sup>0</sup> импульсом КПМГ2, мкс
	to_next_cp2_180 -= 1																				// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	// "Задержка перед 180<sup>0</sup> импульсом CLAY КПМГ"
	var to_next_clay_180 = clay_tau~ - to_aq_shift~ - (to_echo_aq~ / 2)									// Задержка перед 180<sup>0</sup> импульсом CLAY КПМГ, мкс
	to_next_clay_180 -= 1																				// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	// "Первый интревал для насыщающей последовательности"
	var t1 = 200;											// Первый интревал для насыщающей последовательности, мкс
	
	// "Число окон для шума"
	var noise_num = noise_group~ * echoes_accum~										// Число окон для шума
	// "Число окон для эхо"
	var echoes_num = echoes_group~ * echoes_accum~										// Число окон для эхо
	// "Первое cpmg1_tau, скорректированное с учетом длительности РЧ импульсов, мкс"
	var cpmg1_tau1 = cpmg1_tau~ - cpmg_rfp_90~ / 2
	// "Первое cpmg2_tau, скорректированное с учетом длительности РЧ импульсов, мкс"
	var cpmg2_tau1 = cpmg2_tau~ - cpmg_rfp_90~ / 2
	// "Первое clay_tau, скорректированное с учетом длительности РЧ импульсов, мкс"
	var clay_tau1 = clay_tau~ - cpmg_rfp_90~ / 2
	// "Задержка перед началом измерений, мкс"
	var before_aq = 50000 - 1
	// "Интервал повторения, мкс"
	var to_data_tx = to_relax~ * 1000 - (before_aq + cpmg1_enb~*(2*cpmg1_tau~*noise_group~*echoes_accum~ + to_echo_proc * (echoes_group~ + noise_group~) + 20000 + to_strobe) + cpmg2_enb~*(to_cpmg2~ + 2*cpmg2_tau~*noise_group~*echoes_accum~ + to_echo_proc * (echoes_group~ + noise_group~) + 20000 + to_strobe) + clay_enb~*(to_echo_proc*(echoes_clay~ + 1) + 30000 + to_strobe) + to_strobe);


//-----------------------------------------------------------------------------------------------------------
// Блок запрашиваемых данных из каротажного прибора
// [Output]

	@parameter cpmg1_enb = { "КПМГ1", 1 }
	cpmg1_enb.comment = "Включить измерения на cpmg_channel";
	cpmg1_enb.exec((cpmg1_enb~ == 1) ? 0 : (8388608 + 41))			// Если cpmg1_enb = 0, перейти на 41 комманд вперед
	cpmg1_enb.uitype = "checkbox";
	
	var cpmg1_enb2 = (cpmg1_enb~ == 1) ? 0 : (8388608 + 6);
	
	@parameter cpmg2_enb = { "КПМГ2", 0 }
	cpmg2_enb.comment = "Включить канал ЯМР";
	cpmg2_enb.exec((cpmg2_enb~ == 1) ? 0 : (8388608 + 42))			// Если cpmg2_enb = 0,перейти на 53 комманд вперед
	cpmg2_enb.uitype = "checkbox";
	
	var cpmg2_enb2 = (cpmg2_enb~ == 1) ? 0 : (8388608 + 6)
	
	@parameter clay_enb = { "Глина", 0 }
	clay_enb.comment = "Включить канал ЯМР";
	clay_enb.exec((clay_enb~ == 1) ? 0 : (8388608 + 39))			//Если cpmg2_enb = 0, перейти на 40 комманд вперед
	clay_enb.uitype = "checkbox";
	
	@parameter echo_enb = { "Сигнал эхо", 0 }
	echo_enb.comment = "Включить Сигнал эхо";
	echo_enb.uitype = "checkbox";
	
	@parameter furie_enb = { "Cпектр эхо", 0 }
	furie_enb.comment = "Включить Cпектр эхо";
	furie_enb.uitype = "checkbox";
	
	@output o_out = { "Output" }
	o_out.append(cpmg1_enb);
	o_out.append(cpmg2_enb);
	o_out.append(clay_enb);
	o_out.append(echo_enb);
	o_out.append(furie_enb);

// -----------------------------------------------------------------------------------------------------------
// Проверяемые после вычислений условия
// Условия накладываются на вычисленные значения параметров перед внесением параметров в интервальную последовательность.
// Если условие не выполняется, то параметры не записываются в интервальную последовательность, и выдаётся соответствующее сообщение.
// -----------------------------------------------------------------------------------------------------------
// [Conditions]

	@condition D1 = { "Проверка устанавливаемой длительности или смещения окна АЦП" }
	D1.msg = "При установленном tau невозможно установить длительность и/или смещение окна АЦП";
	D1.hint = "Проверка устанавливаемой длительности или смещения окна АЦП";
	D1.exec(cpmg1_tau~ + to_aq_shift~ - (to_echo_aq~ /2));
	
	@condition D2 = { "Проверка устанавливаемой длительности периода повторения" }
	D2.msg = "Период между последовательностями мал.";
	D2.hint = "Проверка устанавливаемой длительности периода повторения";
	D2.exec(to_relax~ * 1000 - (before_aq + cpmg1_enb~*(2*cpmg1_tau~*noise_group~*echoes_accum~ + to_echo_proc * (echoes_group~ + noise_group~) + 20000 + to_strobe) + cpmg2_enb~*(to_cpmg2~ + 2*cpmg2_tau~*noise_group~*echoes_accum~ + to_echo_proc * (echoes_group~ + noise_group~) + 20000 + to_strobe) + clay_enb~*(to_echo_proc*(echoes_clay~ + 1) + 30000 + to_strobe) + to_strobe));
	
	@condition D3 = { "Проверка ограничения числа окон АЦП" }
	D3.msg = "Слишком  много окон АЦП";
	D3.hint = "Проверка ограничения числа окон АЦП";
	D3.exec(500 - (noise_group~ + echoes_group~));

// -----------------------------------------------------------------------------------------------------------
// Блок параметров обработки сигнала
// [Processing]

	// "Метод вычитания шума"
	var proc_id = 4;																				// Методы вычитания шума: 0 - не вычитать шум, 1 - вычитать по методу В.Д., 2 - вычитать амплитудные спектры, 3 - выводить только шум, 4 - вычитать интегралы
	// "Коэфициент для первого эхо"
	var k_fe = 1200;																				// Коэфициент для первого эхо
	// "Время на вычисление"
	var to_echo_proc = 800;																			// Время на выполнение пакетов инструкций по вычислению амплитуд эхо, мкс
	// "Время на вычисление"
	var to_echoes_proc = to_echo_proc*(echoes_group~ + noise_group~ + 1) + 20000 - 1;				// Время на выполнение пакетов инструкций по вычислению амплитуд эхо КПМГ1 и КПМГ2, мкс
	// "Время на вычисление"
	var to_clay_echoes_proc = to_echo_proc*(echoes_clay~ + 1) + 30000 - 1;							// Время на выполнение пакетов инструкций по вычислению амплитуд эхо CLAY КПМГ, мкс
	// "Длительность стробов для процессора"
	var to_strobe = 500 - 1;																		// Длительность стробов для передачи управляющих команд от ПЛИС к процессору, мкс
	
	// параметры оконных функций во временной области
	// Тип фильтра во врем. обл.
	var win_type = 2;																				// Значение: 0 - прямоугольная функция, 1 - гауссовая форма, 2 - бигауссовая форма
	// Сдвиг фильтра во врем. обл.
	var time_shift = 0 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Сдвиг оконной функции во временной области для обработки сигнала, мкс
	// Ширина фильтра во врем. обл.
	var time_width = 300 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Ширина оконной функции во временной области для обработки, мкс
	// Сдвиг фильтра в част. обл.
	var freq_shift = 250 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Сдвиг оконной функции в частотной области для обработки сигнала, кГц
	// Ширина фильтра в част. обл.
	var freq_width = 4 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Ширина оконной функции в частотной области для обработки сигнала, кГц
	
	@parameter emul = { "Эмуляция данных", 0, min=0, max=1 }
	emul.comment = "Эмулировать исходные данные ЯМР ? (Да/Нет)";
	//emul.uitype = "combobox";
	
	@parameter sn = { "Сигнал/шум", 5, min=0.001 }
	sn.comment = "Отношение сигнал/шум";
	//sn.ron = emul~ == 0;
	
	@section s_dataorg = { "Источник данных" }
	s_dataorg.append(emul);
	s_dataorg.append(sn);

// -----------------------------------------------------------------------------------------------------------
// Блок правил расчёта временных отсчётов для принимаемых и сохраняемых массивов амплитуд
// При расчёте временных отсчётов по указанной в описании формуле индекс инкрементно увеличивается на 1.
//[Arguments]

	function cpmg_X(N, acc, tau)
	{
		var pts = new Array(N);
		for (var i = 0; i < N; ++i) { pts[i] = tau + tau * acc *(2*i + 1) / 1000 };
		return pts;
	}
	
	
	function clay_X(N, tau)
	{
		var pts = new Array(N);
		for (var i = 0; i < N; ++i) { pts[i] = 2*tau * (i + 1) / 1000 };
		return pts;
	}
	
	@argument cpmg1_X = { "Временные отсчёты эхо в последовательности КПМГ1" }
	cpmg1_X.units = "ms";
	cpmg1_X.size = echoes_group~;
	cpmg1_X.points = cpmg_X(cpmg1_X.size, echoes_accum~, cpmg1_tau~);
	
	@argument cpmg2_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg2_X.units = "ms";
	cpmg2_X.size = echoes_group~;
	cpmg2_X.points = cpmg_X(cpmg1_X.size, echoes_accum~, cpmg2_tau~);
	
	@argument clay_X = { "Временные отсчёты эхо в последовательности CLAY КПМГ" }
	clay_X.units = "ms";
	clay_X.size = echoes_clay~;
	clay_X.points = cpmg_X(clay_X.size, clay_tau~);


// ************************** Пакеты инструкций **************************************************************
// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_001]
	@proc STD_ECHO = { "ECHO sample" }
	#begin(STD_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, noise_num, echoes_accum, sn, 1, k_fe)                                  
		INS_NO_OP(0, 0)
	#end
	 
	// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_002]
	@proc CLAY_ECHO = { "CLAY ECHO sample" }
	#begin(CLAY_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, 1, echoes_clay, sn, 0, k_fe)                                  
		INS_NO_OP(0, 0)
	#end
	
	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ1, формирование массива для передачи данных
	// [Package_003]
	@proc CPMG1 = { "Decay calc" }
	#begin(CPMG1)
		//INS_WIN_TIME, 3, 0, win_type, time_shift, time_width
		//INS_WIN_FREQ, 3, 0, win_type, freq_shift, freq_width
		INS_SGN_PROC3(9, 0, noise_num, echoes_num, echoes_accum, proc_id, echo_enb, furie_enb, 1, 1, 1)          // вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, 500)                                                                               // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                          // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end
		
	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд ClAY КПМГ, формирование массива для передачи данных
	// [Package_004]
	@proc ClAY = { "Clay decay calc" }
	#begin(ClAY)
		INS_SGN_PROC3(9, 0, 1, echoes_clay, accum_clay, proc_id, echo_enb, furie_enb, 0, 3, 3)                   // вычисление амплитуды                                          
		INS_CLEAR_HX(2, 0, 0, 500)                                                                               // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                          // очистка указателя стека                                       
		INS_NO_OP(0, 0)           
	#end
	
	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ2, формирование массива для передачи данных
	// [Package_005]
	@proc CPMG2 = { "Decay calc" }
	#begin(CPMG2)
		//INS_WIN_TIME, 3, 0, win_type, time_shift, time_width
		//INS_WIN_FREQ, 3, 0, win_type, freq_shift, freq_width
		INS_SGN_PROC3(9, 0, noise_num, echoes_num, echoes_accum, proc_id, echo_enb, furie_enb, 1, 2, 2)          // вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, 500)                                                                               // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                          // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end
// ***********************************************************************************************************


// ***********************************************************************************************************
// Интервальная программа
// Структура: 
// (имя команды), (первый байт команды), (второй байт команды), (третий байт команды) – явное задание параметров команды 
// (имя команды), (имя параметра) – неявное, настраиваемое задание параметров команды; 
// -----------------------------------------------------------------------------------------------------------

// [Commands]
// Инициализация и задержка на передачу данных
// 12 * 0,4 мкс = 4,8 мкс + delay_before_rf_pulses
@comm fpga = { "FPGA program" }
#begin(fpga)
	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Инициализация канала cpmg_channel
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_TIME 0, 1, 255          	           // интервал для SPI
		COM_SWITCH_FRQ cpmg_channel               // установка базовых частот канала ЯМР
		COM_OFS01 cpmg_frq_ofs                    // установка гетеродинной частоты передатчика
		COM_OFS02 tx_frq2_ofs                     // установка вспомогательной частоты передатчика 
		COM_OFS03 cpmg_frq_ofs                    // установка гетеродинной частоты приёмника
		COM_OFS05 adc_frq_ofs                     // установка частоты дискретизации АЦП относительно базовой частоты
		COM_PH_RST 0, 0, 0                        // синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
		COM_SET_VC_DAC_2 vc_dac                   // установка напряжения на варикапах
		COM_TIME 0, 1, 255          	           // интервал для SPI
		COM_SET_GAIN_1 KU                         // установка коэффициента ослбления приемника
		COM_GRADIENT_ON 0, 0, 1                   // включение постоянного градиента
							   //
		COM_TIME before_aq          	           // Задержка на установление режимов работы устройств
		COM_PROC_CONTROL_STB_3 0, 0, 1            // установления флага начала общего окна данных

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	КПМГ 1. канал cpmg_channel.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_MACRO_OVER_JUMP cpmg1_enb             // Если cpmg1_enb = 0, пропустить КПМГ 1
		COM_PROC_CONTROL_STB_2 0, 0, 1            // установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП

	// Измерение шума во внутреннем цикле 
		COM_CYCLE_OPEN noise_num                  // начало цикла для измерений шума (to_cpmg1_blank_pulse + to_echo_aq + to_next_cp1_180)*noise_num 
		COM_TIME to_cpmg1_blank_pulse             // интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
		COM_TIME to_aq_start					   //
		var is_blanked = 1;
		COM_BLANK_PWR is_blanked				   //
		COM_TIME to_echo_aq                       // время оцифровки сигнала
		COM_PROC_CONTROL_STB_1 0, 254, 1          // запуск АЦП
		COM_TIME to_next_cp1_180                  // пауза до следующего окна шума в цикле
		COM_BLANK_PWR 0 ,0 ,0					   //
		COM_PROC_CONTROL_STB_1 0, 1, 0            // останов АЦП, выполнение Package_001
		COM_CYCLE_CLOSE 0, 0, 0                   // окончание цикла измерений шума

	// Формирование и измерение эхо во внутреннем цикле
		// - формирование 90-град. РЧ импульса
		COM_PH01 ph_90                            // установка фазы 90 град. импульса
		COM_TIME cpmg1_tau1                       // интервал времени cpmg1_tau с поправкой на длительность импульса
		COM_PH_RST 0, 0, 1                        // синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса

		// - формирование цикла из 180-град. РЧ импульсов, измерение и накопление амплитуды эхо 
		COM_CYCLE_OPEN echoes_num                 // начало цикла для эхо
		COM_TIME to_cpmg1_blank_pulse             // интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
		COM_PH01 ph_180                           // установка фазы 180 град. импульса
		COM_RF01 cpmg_rfp_180                     // запуск РЧ импульса
		COM_TIME to_aq_start					   //
		COM_BLANK_PWR is_blanked				   //
		COM_TIME to_echo_aq                       // время оцифровки сигнала
		COM_PROC_CONTROL_STB_1 0, 254, 1          // запуск АЦП
		COM_TIME to_next_cp1_180                  // пауза до следующего РЧ импульса в цикле КПМГ
		COM_BLANK_PWR 0 ,0 ,0					   //
		COM_PROC_CONTROL_STB_1 0, 1, 0            // останов АЦП, выполнение Package_001
		COM_CYCLE_CLOSE 0, 0, 0                   // окончание цикла измерений эхо

	// Насыщающая последовательность 90-градусных импульсов [time = t1 + t2 + t3 + t4 + t5 + t6] 
		COM_PH01 ph_90	                           // установка фазы 90 град. импульса
		COM_TIME t1*32	                            // интервал времени t1
		COM_EMPTY 0, 0, 0 // COM_RF01, cpmg_rfp_90// запуск РЧ импульса
		COM_TIME t1*16                            // интервал времени t2
		COM_EMPTY 0, 0, 0 // COM_RF01, cpmg_rfp_90// запуск РЧ импульса
		COM_TIME t1*8                             // интервал времени t3
		COM_EMPTY 0, 0, 0 // COM_RF01, cpmg_rfp_90// запуск РЧ импульса
		COM_TIME t1*4                             // интервал времени t4
		COM_EMPTY 0, 0, 0 // COM_RF01, cpmg_rfp_90// запуск РЧ импульса
		COM_TIME t1*2                             // интервал времени t5
		COM_EMPTY 0, 0, 0 // COM_RF01, cpmg_rfp_90// запуск РЧ импульса
		COM_TIME t1                               // интервал времени t6
		COM_EMPTY 0, 0, 0 // COM_RF01, cpmg_rfp_90// запуск РЧ импульса
		COM_PROC_CONTROL_STB_2 0, 0, 0            // сброс счётчика окон

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	КПМГ1. Вычисление амплитуд, формирование буфера передачи данных.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

	// to_echoes_proc
		COM_MACRO_OVER_JUMP cpmg1_enb2            // Если cpmg1_enb = 0, пропустить расчет КПМГ 1
		COM_TIME to_strobe                        // длительность строба идентификации пакета
		COM_PROC_CONTROL_STB_2 0, 0, 0            // установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
		COM_PROC_CONTROL_STB_1 0, 200, 1          // флаг фиктивного устройства
		COM_TIME to_echoes_proc                   // Время рассчета амплитуд КПМГ и измерения ВДК
		COM_PROC_CONTROL_STB_1 0, 3, 0            // снятие флага окна АЦП, выполнение Package_003

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	CLAY КПМГ. канал cpmg_channel. Короткий КПМГ, с минимальным тау, для измерения глининсто связанного флюида.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_MACRO_OVER_JUMP clay_enb              // Если clay_enb = 0, пропустить CLAY КПМГ 
		//COM_DAMP01_CFG is_dumped_force            // включение демпфирования и установка длительности
		COM_SET_ACC_02 ph_180					   //
												   //
		COM_TIME to_clay						   //
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса, чтобы оставить только короткую копоненту
												   //
		COM_CYCLE_OPEN accum_clay                 // начало цикла [[2*clay_tau + 1]*echoes_clay + to_clay]*accum_clay

	// Измерение и накопление шума
		COM_TIME to_clay_blank_pulse              // интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
		COM_PROC_CONTROL_STB_2 0, 0, 1            // установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
		COM_PH_RST 0, 0, 1                        // синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
		COM_TIME to_aq_start					   //
		COM_BLANK_PWR is_blanked				   //
		COM_TIME to_echo_aq                       // время оцифровки сигнала
		COM_PROC_CONTROL_STB_1 0, 254, 1          // запуск АЦП
		COM_TIME to_next_clay_180                 // пауза до следующего окна шума в цикле
		COM_BLANK_PWR 0 ,0 ,0					   //
		COM_PROC_CONTROL_STB_1 0, 2, 0            // останов АЦП, выполнение Package_002

	// Формирование и измерение эхо во внутреннем цикле
		// - формирование 90-град. РЧ импульса
		COM_PH01 ph_90                            // установка фазы 90 град. импульса
		COM_TIME clay_tau1                        // интервал времени cpmg1_tau с поправкой на длительность импульса
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса

		// - формирование цикла из 180-град. РЧ импульсов, измерение и накопление амплитуды эхо 
		COM_CYCLE_OPEN echoes_clay                // начало цикла для эхо
		COM_TIME to_clay_blank_pulse              // интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
		COM_ACC_TO_PH 0, 2, 1                     // установка фазы 180 град. импульса
		COM_RF01 cpmg_rfp_180					   // запуск РЧ импульса
		COM_TIME to_aq_start					   //
		COM_BLANK_PWR is_blanked				   //
		COM_TIME to_echo_aq                       // время оцифровки сигнала
		COM_PROC_CONTROL_STB_1 0, 254, 1          // запуск АЦП
		COM_TIME to_next_clay_180                 // пауза до следующего РЧ импульса в цикле КПМГ
		COM_BLANK_PWR 0 ,0 ,0					   //
		COM_PROC_CONTROL_STB_1 0, 2, 0            // останов АЦП, выполнение Package_002
		COM_CYCLE_CLOSE 0, 0, 0                   // окончание цикла измерений эхо
												   //
		COM_TIME to_clay                          // пауза до следующего КПМГ
		COM_ADD_TO_ACC_02 dph                     // инкремент фазы
		COM_PROC_CONTROL_STB_2 0, 0, 0            // сброс счётчика окон
												   //
		COM_CYCLE_CLOSE 0, 0, 0                   // окончание фазового цикла

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	CLAY КПМГ. Вычисление амплитуд, формирование буфера передачи данных.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

	// to_echoes_proc
		COM_TIME to_strobe                        // длительность строба идентификации пакета
		COM_PROC_CONTROL_STB_2 0, 0, 0            // установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
		COM_PROC_CONTROL_STB_1 0, 200, 1          // флаг фиктивного устройства для выполнения пакета
		COM_TIME to_clay_echoes_proc              // Время рассчета амплитуд КПМГ и измерения ВДК
		COM_PROC_CONTROL_STB_1 0, 4, 0            // снятие флага окна АЦП, выполнение Package_004

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	КПМГ 2. канал cpmg_channel.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_MACRO_OVER_JUMP cpmg2_enb             // Если cpmg2_enb = 0, пропустить КПМГ 2
		COM_TIME to_cpmg2           	           // Время между cpmg1 и cpmg2 и на установление режимов работы каналов приемника
		COM_PROC_CONTROL_STB_2 0, 0, 1            // установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП

	// Измерение и накопление шума                   [time = (to_cpmg2_blank_pulse + to_echo_aq + to_next_cp2_180)*noise_num]
		COM_CYCLE_OPEN noise_num                  // начало цикла для измерений шума
		COM_TIME to_cpmg2_blank_pulse             // интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
		COM_TIME to_aq_start					   //
		COM_BLANK_PWR is_blanked				   //
		COM_TIME to_echo_aq                       // время оцифровки сигнала
		COM_PROC_CONTROL_STB_1 0, 254, 1          // запуск АЦП
		COM_TIME to_next_cp2_180                  // пауза до следующего окна шума в цикле
		COM_BLANK_PWR 0, 0, 0					   //
		COM_PROC_CONTROL_STB_1 0, 1, 0            // останов АЦП, выполнение Package_001
		COM_CYCLE_CLOSE 0, 0, 0                   // окончание цикла измерений шума
		
	// Формирование и измерение эхо                  [time = cpmg2_tau1 +  2*cpmg2_tau * (echoes_num + 1)]
		// - формирование 90-град. РЧ импульса
		COM_PH01 ph_90                            // установка фазы 90 град. импульса
		COM_TIME cpmg2_tau1                       // интервал времени cpmg1_tau с поправкой на длительность импульса
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса

		// - формирование цикла 180-град. РЧ импульсов 
		COM_CYCLE_OPEN echoes_num                 // начало цикла для эхо
		COM_TIME to_cpmg2_blank_pulse             // интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
		COM_PH01 ph_180                           // установка фазы 180 град. импульса
		COM_RF01 cpmg_rfp_180                     // запуск РЧ импульса
		COM_TIME to_aq_start					   //
		COM_BLANK_PWR is_blanked				   //
		COM_TIME to_echo_aq                       // время оцифровки сигнала
		COM_PROC_CONTROL_STB_1 0, 254, 1          // запуск АЦП
		COM_TIME to_next_cp2_180                  // пауза до следующего РЧ импульса в цикле КПМГ
		COM_BLANK_PWR 0, 0, 0					   //
		COM_PROC_CONTROL_STB_1 0, 1, 0            // останов АЦП, выполнение Package_001
		COM_CYCLE_CLOSE 0, 0, 0                   // окончание цикла измерений эхо

	// Насыщающая последовательность 90-градусных импульсов [time = t1 + t2 + t3 + t4 + t5 + t6] 
		COM_PH01 ph_90                            // установка фазы 90 град. импульса
		COM_TIME t1*32                               // интервал времени t1
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса
		COM_TIME t1*16                               // интервал времени t2
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса
		COM_TIME t1*8                               // интервал времени t3
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса
		COM_TIME t1*4                               // интервал времени t4
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса
		COM_TIME t1*2                               // интервал времени t5
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса
		COM_TIME t1                               // интервал времени t6
		COM_RF01 cpmg_rfp_90                      // запуск РЧ импульса
		COM_PROC_CONTROL_STB_2 0, 0, 0            // сброс счётчика окон

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	КПМГ 2. Вычисление амплитуд, формирование буфера передачи данных.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

	// to_echoes_proc
		COM_MACRO_OVER_JUMP cpmg2_enb2            // Если cpmg2_enb = 0, пропустить расчет КПМГ 2
		COM_TIME to_strobe                        // длительность строба идентификации пакета
		COM_PROC_CONTROL_STB_2 0, 0, 0            // установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
		COM_PROC_CONTROL_STB_1 0, 200, 1          // флаг фиктивного устройства для выполнения пакета
		COM_TIME to_echoes_proc                   // Время рассчета амплитуд КПМГ
		COM_PROC_CONTROL_STB_1 0, 5, 0            // снятие флага окна АЦП, выполнение Package_005

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Передача данных.                                  [time = to_strobe + to_data_tx + 1]
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_TIME to_strobe                        // интервал до времени отдыха на разнесение стробов
		COM_PROC_CONTROL_STB_3 0, 0, 0            // установления флага окончания общего окна данных, передача данных в рабочую станцию
		COM_TIME to_data_tx                       // интервал до начала следующей последовательности, в котором выполняется передача данных
		COM_GRADIENT_ON 0, 0, 0                   // выключение постоянного градиента
		COM_TIME 0, 0, 0                          // интервал для команды 1 мкс
		COM_RET 0, 0, 0                           // возврат в начало

#end
// ***********************************************************************************************************


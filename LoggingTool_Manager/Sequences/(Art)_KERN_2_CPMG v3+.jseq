// [Main]

// Описание: Стандартная активация T2, Двойная активация, Активация глин, Активация солид
// Назначение: Активация позволяет получать релаксационный спад (эхо-сигнала) при таком времени ожидания (time waiting) Tw, что пластовые флюиды полностью поляризованы,
// и минимальном интервале между эхо (time between echo) Te=2*tau, при котором сводятся к минимумам эффекты диффузии на амплитуду спинового эхо.
// Посмледовательность: [[Aq(noise)]a]n-Tw1-90-tau-180-tau-Aq(echo)-tau-[180-tau-Aq(echo)-tau]a]i-90-t1-90-t2-90-t3-90-t4-90-t5-90-t6-90-Tw2-Send
// Ядро преобразования: Kij=exp(-ti/T2j) 
// Первичная цифровая обработка сигналов:
// - сигналы шума и сигналы спинового эхо измеряются;
// - вычисляются мощностные спектры шума и спиновых эхо;
// - с учётом усреднённого мощностного спектра шума вычисляются амплитуды полезного сигнала спинового эхо
// Контроль обработки данных:
// - сигнал с оконнной функцией
// - амплитудный спектр мощности спектров сигнала и шума
// Вывод данных:
// - амплитуды спинового эхо в последовательности КПМГ

main.name = "2 CPMG with 1 Clay CPMG v.1"
main.author = "КФУ: Скирда В.Д., Александров А.А., Савинков А.В, Дорогиницкий М.М."
main.datetime = "10.10.2017 11:50"
main.description = "Стандартная активация T2, Двойная активация, Активация глин, Активация солид"


// Блок констант
// [Constants]
	var DDS_CLK_FRQ = 250000 													// Тактовая частота DDS (кГц) (константа, прошита в ПЛИС)
	var IF_FRQ = 1250															// Промежуточная частота приемника (кГц) (константа, задана аппаратно)
	var NMR_SAMPLE_FREQ = 5000													// Частота дискретизации (кГц) (константа, задана аппаратно)
	
	var n_cmpg_max = 8
	// Таблица TW для измерений T1-T2
	var TWs = new Array(n_cmpg_max)
	TWs[1] = 1280 
	TWs[2] = 640
	TWs[3] = 320
	TWs[4] = 160
	TWs[5] = 80
	TWs[6] = 40
	TWs[7] = 20
	TWs[8] = 10
	// Таблица TW для измерений T2-Ds
	var TEs = new Array(n_cmpg_max)
	TEs[1] = 200
	TEs[2] = 400
	TEs[3] = 800
	TEs[4] = 1600
	TEs[5] = 3200
	TEs[6] = 6400
	TEs[7] = 12800
	TEs[8] = 25600
	
//-----------------------------------------------------------------------------------------------------------
// Блок выбора режима измерений
// [Measure]

	var n_cmpg = 0

	@parameter std_act_enb = { "Стандартная активация", 1 }
	std_act_enb.comment = "Включить измерения КПМГ1";
	std_act_enb.uitype = "checkbox";
	if (std_act_enb~ == 1) {n_cmpg = 1}

	@parameter double_act_enb = { "Двойная активация", 0, min=0, max=2 }
	double_act_enb.comment = "Включить измерения КПМГ2";
	double_act_enb.uitype = "spinbox";
	if (double_act_enb~ > 0) {n_cmpg = 2}
	
	@parameter clay_act_enb = { "Активация Глин", 0 }
	clay_act_enb.comment = "Включить измерения ClAY КПМГ";
	clay_act_enb.uitype = "checkbox";
	var clay_activation = clay_act_enb~

	@parameter solid_act_enb = { "Активация Solid", 0 }
	solid_act_enb.comment = "Включить измерения солид эхо";
	solid_act_enb.uitype = "checkbox";
	var solid_activation = solid_act_enb~

	var D2_type = 0
	@parameter D2_act_enb = { "Активация 2D ", 0, min=0, max=2}
	D2_act_enb.comment = "Включить измерения КПМГ 1-8";
	if (D2_act_enb~ == 1) {n_cmpg = 8}
		
	@parameter echo_enb = { "Сигнал эхо", 0 }
	echo_enb.comment = "Включить Сигнал Эхо";
	echo_enb.uitype = "checkbox";
	
	//@output meas = { "Режим измерений" }
	@section meas = { "Режим измерений" }
	meas.append(std_act_enb)
	meas.append(double_act_enb)
	meas.append(clay_act_enb)
	meas.append(solid_act_enb)
	meas.append(D2_act_enb)
	meas.append(echo_enb)
	
//-----------------------------------------------------------------------------------------------------------
// Блок параметров частот
// [Frequencies]

	@parameter cpmg_frq_ofs = { "Частота резонанса", 0, min=-488, max=488, units="кГц" }
	cpmg_frq_ofs.comment = "Смещение частоты относительно заданной базовой частоты"
	cpmg_frq_ofs.exec(cpmg_frq_ofs~ * 4294967296 / DDS_CLK_FRQ)
	
	@parameter tx_frq2_ofs = { "Опорная частота передачи", 0, min=-488, max=488, units="кГц" }
	tx_frq2_ofs.comment = "Смещение опорной частоты передачи относительно заданной базовой частоты"
	tx_frq2_ofs.exec(tx_frq2_ofs~ / DDS_CLK_FRQ * 4294967296)
	
	// Смещение частоты оцифровки относительно заданной базовой
	var adc_frq_ofs = 0;
	adc_frq_ofs = adc_frq_ofs / DDS_CLK_FRQ * 4294967296;						// Частота АЦП
		
	@section s_freqs = { "Частоты" }
	s_freqs.append(cpmg_frq_ofs)

//-----------------------------------------------------------------------------------------------------------
// Блок параметров приемника
// [Reciever]

	@parameter cpmg_channel = { "Номер канала", 1, min=1, max=1 }
	cpmg_channel.comment = "выбор номера канала измерений (0 - первый канал ЯМР, 1 - второй канал ЯМР, ...)"
	cpmg_channel.exec(cpmg_channel~ - 1)

	@parameter vc_dac = { "Настройка антенны", 2000, min=0, max=5000, units="мВ" }
	vc_dac.comment = "Напряжение на варикапах, мВ"
	vc_dac.exec(vc_dac~ * 65535 / 5000)

	@parameter KU = { "Усиление приемника", -10, min=-24, max=0, units="дБ"}
	KU.comment = "Коэффициент усиления приемника"
	KU.exec(- KU~)
	
	@section s_rx = { "Приемник" }
	//s_probes.append(cpmg_channel)
	s_rx.append(vc_dac)
	s_rx.append(KU)

//-----------------------------------------------------------------------------------------------------------
// Блок длительности РЧ-импульсов
// [RF_pulses]

	@parameter cpmg_rfp_90 = { "90<sup>0</sup> импульс. Длительность.", 13, min=0, max=1000, units="мкс" }
	cpmg_rfp_90.comment = "Длительность 90<sup>0</sup> РЧ импульса"
	cpmg_rfp_90.exec(cpmg_rfp_90~ * 10)																	// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	
	@parameter cpmg_rfp_180 = { "180<sup>0</sup> импульс. Длительность.", 26, min=0, max=1000, units="мкс" }
	cpmg_rfp_180.comment = "Длительность 180<sup>0</sup> РЧ импульса"
	cpmg_rfp_180.exec(cpmg_rfp_180~ * 10)																// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
		
	@parameter ph_90 = { "90<sup>0</sup> импульс. Фаза", 0, min=0, max=360, units=" <sup>0</sup>, град." }
	ph_90.comment = "90<sup>0</sup> импульс. Фаза"
	ph_90.exec(ph_90~ * 46603.375)
	
	@parameter ph_180 = { "180<sup>0</sup> импульс. Фаза", 90, min=0, max=360, units=" <sup>0</sup>, град." }
	ph_180.comment = "180<sup>0</sup> импульс. Фаза"
	ph_180.exec(ph_180~ * 46603.375)
	
	// Инкремент фазы. Значение инкремента фазы для фазового циклирования
	var dph = 180
	dph = dph * 46603.375; 																				// "град."
	
	@section s_rf_pulses = { "РЧ импульсы" }
	s_rf_pulses.append(cpmg_rfp_90)
	s_rf_pulses.append(cpmg_rfp_180)
	//s_rf_pulses.append(ph_90)
	//s_rf_pulses.append(ph_180)

//-----------------------------------------------------------------------------------------------------------
// Блок временных параметров последовательности
// [Intervals]
	
	// "Задержка перед началом измерений, мкс"
	var before_aq = 50000 - 1

	@parameter to_cpmg1 = { "Стандартная активация. TW", 2000, min=50, max=16777, units="мс" }
	to_cpmg1.comment = "Время на восстановление намагниченности после измерений"
	
	@parameter to_cpmg2 = { "Двойная активация. TW2", 50, min=50, max=16777, units="мс" }
	to_cpmg2.comment = "Время на восстановление намагниченности после КПМГ1"
	to_cpmg2.exec(to_cpmg2~ * 1000 - 1)																	// *1000 для перевода мс в мкс, минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_clay = { "Активация Глин. TW3", 20, min=10, max=16777, units="мс" }
	to_clay.comment = "Время на восстановление намагниченности глин"
	to_clay.exec(to_clay~ * 1000 - 1)																	// *1000 для перевода мс в мкс, минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter tau_cpmg1 = { "Стандартная активация. TAU", 400, min=300, max=16777, units="мкс" }
	tau_cpmg1.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ1"
	
	@parameter tau_cpmg2 = { "Двойная активация. TAU2", 400, min=300, max=16777, units="мкс" }
	tau_cpmg2.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ2"
	
	@parameter tau_clay = { "Активация Глин. TAU3", 300, min=300, max=16777, units="мкс" }
	tau_clay.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности CLAY КПМГ "
	
	@parameter to_aq_shift = { "Окно АЦП. Смещение", 20, min=1, max=16777, units="мкс" }
	to_aq_shift.comment = "Смещение окна АЦП от расчетного времени в последовательности КПМГ"
	to_aq_shift.exec(to_aq_shift~ - 1)																	// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_echo_aq = { "Окно АЦП. Длительность.", 150, min=1, max=16777, units="мкс" }
	to_echo_aq.comment = "Длительность окна АЦП для регистрации сигнала спинового эхо в последовательности КПМГ"
	to_echo_aq.exec(to_echo_aq~ - 1)																	// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@section s_delays = { "Интервалы" }
	s_delays.append(to_cpmg1)
	s_delays.append(to_cpmg2)
	s_delays.append(to_clay)
	s_delays.append(tau_cpmg1)
	s_delays.append(tau_cpmg2)
	s_delays.append(tau_clay)
	//s_delays.append(to_aq_shift)
	s_delays.append(to_echo_aq)
	
	var to_cpmg2_t = to_cpmg2~; var tau_cpmg2_t = tau_cpmg2~ 																					
	if (double_act_enb~ == 1) {to_cpmg2_t = to_cpmg2~; tau_cpmg2_t = tau_cpmg1~}
	if (double_act_enb~ == 2) {to_cpmg2_t = to_cpmg1~; tau_cpmg2_t = tau_cpmg2~}
	
	// Массив TW
	var to_cpmg = new Array(n_cmpg_max)	
	to_cpmg[1] = to_cpmg1~ * 1000 - 1 
	to_cpmg[2] = to_cpmg2_t * 1000 - 1
	
	// Массив задержек перед АЦП 
	var to_aq_start = new Array(n_cmpg_max)
	to_aq_start[1] = tau_cpmg1~ + to_aq_shift~ - (to_echo_aq~ / 2) - 1									// Задержка перед АЦП в КПМГ1, мкс
	to_aq_start[2] = tau_cpmg2_t + to_aq_shift~ - (to_echo_aq~ / 2) - 1									// Задержка перед АЦП в КПМГ2, мкс
	// Задержка перед АЦП в CLAY КПМГ, мкс
	var to_aq_start_clay = tau_clay~ + to_aq_shift~ - (to_echo_aq~ / 2)	- 1								// Задержка перед АЦП в CLAY КПМГ, мкс

	// Массив задержек перед 180<sup>0</sup> импульсом
	var to_next_180 = new Array(n_cmpg_max)
	to_next_180[1] = tau_cpmg1~ - to_aq_shift~ - (to_echo_aq~ / 2) - 1									// Задержка перед 180<sup>0</sup> импульсом КПМГ1, мкс
	to_next_180[2] = tau_cpmg2_t - to_aq_shift~ - (to_echo_aq~ / 2) - 1									// Задержка перед 180<sup>0</sup> импульсом КПМГ2, мкс
	// "Задержка перед 180<sup>0</sup> импульсом CLAY КПМГ"
	var to_next_clay_180 = tau_clay~ - to_aq_shift~ - (to_echo_aq~ / 2)	- 1								// Задержка перед 180<sup>0</sup> импульсом CLAY КПМГ, мкс

	// Массив: Первое tau, скорректированное
	var red_tau = new Array(n_cmpg_max)
	red_tau[1] = tau_cpmg1~ - cpmg_rfp_90~ / 2															// Первое tau_cpmg1, скорректированное с учетом длительности РЧ импульсов, мкс
	red_tau[2] = tau_cpmg2_t - cpmg_rfp_90~ / 2															// Первое tau_cpmg2, скорректированное с учетом длительности РЧ импульсов, мкс
	// "Первое tau_clay, скорректированное с учетом длительности РЧ импульсов, мкс"
	var red_tau_clay = tau_clay~ - cpmg_rfp_90~ / 2
	
	// "Интервал повторения, мкс"
	var to_data_tx = to_cpmg[1] - before_aq
	// "Интревал для насыщающей последовательности"
	var t1 = 200

//-----------------------------------------------------------------------------------------------------------
// Блок счетчиков
// [Counters]

	@parameter noise = { "КПМГ(1,2). Окон шума", 32, min=1, max=64 }
	noise.comment = "Число окон АЦП для измерения шума"
	
	@parameter echoes = { "КПМГ(1,2). Окон эхо", 1, min=1, max=500 }
	echoes.comment = "Число окон АЦП для измерения сигналов спинового эхо"
	
	@parameter echoes_clay = { "Канал глин. Окон эхо", 20, min=1, max=300 }
	echoes_clay.comment = "Число групп окон АЦП для измерения сигналов спинового эхо"
	
	@parameter accum_clay = { "Канал глин. Накоплений", 2, min=1, max=4 }
	accum_clay.comment = "Число фазовых циклов"
	accum_clay.exec(2 * accum_clay~)
	
	@section s_counters = { "Counters" }
	s_counters.append(noise)
	s_counters.append(echoes)
	s_counters.append(echoes_clay)
	
	
	
// -----------------------------------------------------------------------------------------------------------
// Блок параметров обработки сигнала
// [Processing]

	// "Метод вычитания шума"
	var proc_id = 4;																				// Методы вычитания шума: 0 - не вычитать шум, 1 - вычитать по методу В.Д., 2 - вычитать амплитудные спектры, 3 - выводить только шум, 4 - вычитать интегралы
	// "Коэфициент для первого эхо"
	var k_fe = 1200;																				// Коэфициент для первого эхо
	// "Время на вычисление"
	var to_echo_proc = 1000;																		// Время на выполнение пакетов инструкций по вычислению амплитуд эхо, мкс
	// "Время на вычисление"
	var to_echoes_proc = to_echo_proc*(echoes~ + noise~ + 1) + 20000 - 1;							// Время на выполнение пакетов инструкций по вычислению амплитуд эхо КПМГ1 и КПМГ2, мкс
	// "Время на вычисление"
	var to_clay_echoes_proc = to_echo_proc*(echoes_clay~ + 1) + 100000 - 1;							// Время на выполнение пакетов инструкций по вычислению амплитуд эхо CLAY КПМГ, мкс
	// "Длительность стробов для процессора"
	var to_strobe = 500 - 1;																		// Длительность стробов для передачи управляющих команд от ПЛИС к процессору, мкс
	
	// параметры оконных функций во временной области
	// Тип фильтра во врем. обл.
	var win_type = 2;																				// Значение: 0 - прямоугольная функция, 1 - гауссовая форма, 2 - бигауссовая форма
	// Сдвиг фильтра во врем. обл.
	var time_shift = 0 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Сдвиг оконной функции во временной области для обработки сигнала, мкс
	// Ширина фильтра во врем. обл.
	var time_width = 300 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Ширина оконной функции во временной области для обработки, мкс
	// Сдвиг фильтра в част. обл.
	var freq_shift = 250 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Сдвиг оконной функции в частотной области для обработки сигнала, кГц
	// Ширина фильтра в част. обл.
	var freq_width = 4 * (NMR_SAMPLE_FREQ + adc_frq_ofs) * 1024;									// Ширина оконной функции в частотной области для обработки сигнала, кГц
	
	@parameter emul = { "Эмуляция данных", 1, min=0, max=1 }
	emul.comment = "Эмулировать исходные данные ЯМР ? (Да/Нет)";
	
	@parameter sn = { "Сигнал/шум", 5, min=0 }
	sn.comment = "Отношение сигнал/шум";
	
	//@section s_dataorg = { "Источник данных" }
	//s_dataorg.append(emul);
	//s_dataorg.append(sn);

// -----------------------------------------------------------------------------------------------------------
// Проверяемые после вычислений условия
// Условия накладываются на вычисленные значения параметров перед внесением параметров в интервальную последовательность.
// Если условие не выполняется, то параметры не записываются в интервальную последовательность, и выдаётся соответствующее сообщение.
// -----------------------------------------------------------------------------------------------------------
// [Conditions]

	@condition D1 = { "Проверка устанавливаемой длительности или смещения окна АЦП" }
	D1.msg = "При установленном tau невозможно установить длительность и/или смещение окна АЦП";
	D1.hint = "Проверка устанавливаемой длительности или смещения окна АЦП";
	D1.exec(tau_cpmg1~ + to_aq_shift~ - (to_echo_aq~ /2));

	@condition D3 = { "Проверка ограничения числа окон АЦП" }
	D3.msg = "Слишком  много окон АЦП";
	D3.hint = "Проверка ограничения числа окон АЦП";
	D3.exec(500 - (noise~ + echoes~));

// -----------------------------------------------------------------------------------------------------------
// Блок правил расчёта временных отсчётов для принимаемых и сохраняемых массивов амплитуд
// При расчёте временных отсчётов по указанной в описании формуле индекс инкрементно увеличивается на 1.
//[Arguments]

	function cpmg_X(N, tau)
	{
		var pts = new Array(N);
		for (var i = 0; i < N; ++i) { pts[i] = 2*tau * (i + 1) / 1000 };
		return pts;
	}
	
	@argument cpmg1_X = { "Временные отсчёты эхо в последовательности КПМГ1" }
	cpmg1_X.units = "ms";
	cpmg1_X.size = echoes~;
	cpmg1_X.points = cpmg_X(cpmg1_X.size, tau_cpmg1~);
	
	@argument cpmg2_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg2_X.units = "ms";
	cpmg2_X.size = echoes~;
	cpmg2_X.points = cpmg_X(cpmg1_X.size, tau_cpmg2~);
	
	@argument clay_X = { "Временные отсчёты эхо в последовательности CLAY КПМГ" }
	clay_X.units = "ms";
	clay_X.size = echoes_clay~;
	clay_X.points = cpmg_X(clay_X.size, tau_clay~);


// ************************** Пакеты инструкций **************************************************************
// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_001]
	@proc STD_ECHO = { "ECHO" }
	#begin(STD_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, noise, 1, sn, 1, k_fe)                                  
		INS_NO_OP(0, 0)
	#end
	 
	// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_002]
	@proc CLAY_ECHO = { "CLAY ECHO" }
	#begin(CLAY_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, 1, echoes_clay, sn, 0, k_fe)                                  
		INS_NO_OP(0, 0)
	#end
	
	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ1, формирование массива для передачи данных
	// [Package_003]
	@proc CPMG1 = { "Decay calc" }
	#begin(CPMG1)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes, 1, proc_id, echo_enb, echo_enb, 1, 1, 1)								// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, 500)                                                                              // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ2, формирование массива для передачи данных
	// [Package_004]
	@proc CPMG2 = { "Decay calc" }
	#begin(CPMG2)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes, 1, proc_id, echo_enb, echo_enb, 1, 2, 2)								// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, 500)                                                                              // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end	

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд ClAY КПМГ, формирование массива для передачи данных
	// [Package_005]
	@proc ClAY = { "Clay decay calc" }
	#begin(ClAY)
		INS_SGN_PROC3(9, 0, 1, echoes_clay, accum_clay, proc_id, echo_enb, echo_enb, 0, 3, 3)					 // вычисление амплитуды                                          
		INS_CLEAR_HX(2, 0, 0, 500)                                                                               // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                          // очистка указателя стека                                       
		INS_NO_OP(0, 0)           
	#end
	
	// Массив номеров пакетов
	var CMPG_pkg_num = new Array(n_cmpg_max)
	CMPG_pkg_num[1] = CPMG1.id; CMPG_pkg_num[2] = CPMG2.id;

// ***********************************************************************************************************


// ***********************************************************************************************************
// Интервальная программа
// Структура: 
// (имя команды), (первый байт команды), (второй байт команды), (третий байт команды) – явное задание параметров команды 
// (имя команды), (имя параметра) – неявное, настраиваемое задание параметров команды; 
// -----------------------------------------------------------------------------------------------------------

// [Commands]
// Инициализация и задержка на передачу данных
// 12 * 0,4 мкс = 4,8 мкс + delay_before_rf_pulses
@comm fpga = { "FPGA program" }
#begin(fpga)
	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Инициализация канала cpmg_channel
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************
				
		COM_TIME 0, 1, 255          				// интервал для SPI
		COM_SWITCH_FRQ cpmg_channel					// установка базовых частот канала ЯМР
		COM_OFS01 cpmg_frq_ofs						// установка гетеродинной частоты передатчика
		COM_OFS02 tx_frq2_ofs						// установка вспомогательной частоты передатчика 
		COM_OFS03 cpmg_frq_ofs						// установка гетеродинной частоты приёмника
		COM_OFS05 adc_frq_ofs						// установка частоты дискретизации АЦП относительно базовой частоты
		COM_PH_RST 0, 0, 0							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
		COM_SET_VC_DAC_2 vc_dac						// установка напряжения на варикапах
		COM_TIME 0, 1, 255          				// интервал для SPI
		COM_SET_GAIN_1 KU							// установка коэффициента ослбления приемника
		COM_GRADIENT_ON 0, 0, 1						// включение постоянного градиента
													//
		COM_TIME before_aq          				// Задержка на установление режимов работы устройств
		COM_PROC_CONTROL_STB_3 0, 0, 1				// установления флага начала общего окна данных

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Стандартная (КПМГ)(n_cmpg=1) и Двойная (2 КПМГ)(n_cmpg=1) активация. канал cpmg_channel.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************
		
		for (var i = 1; i <= n_cmpg; ++i)				// std_activation = 0, пропустить КПМГ 1,2
		{			
			COM_TIME to_strobe							// длительность строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 1				// установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП

			// Измерение шума во внутреннем цикле 
			COM_CYCLE_OPEN noise						// начало цикла для измерений шума
			COM_TIME to_aq_start[i]						// интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
			COM_TIME to_echo_aq							// время оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_180[i]						// пауза до следующего окна шума в цикле
			COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001
			COM_CYCLE_CLOSE 0, 0, 0						// окончание цикла измерений шума

			if (i > 1) 
			{ 
				COM_TIME to_cpmg[i]						// интервал TWi
				COM_RF01 cpmg_rfp_90					// запуск РЧ импульса
			}			
			
			// Формирование и измерение эхо во внутреннем цикле
			// - формирование 90-град. РЧ импульса
			COM_TIME red_tau[i]							// интервал времени tau_cpmg1 с поправкой на длительность импульса
			COM_PH_RST 0, 0, 1							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
			COM_PH01 ph_90								// установка фазы 90 град. импульса
			COM_RF01 cpmg_rfp_90						// запуск РЧ импульса

			// - формирование цикла из 180-град. РЧ импульсов, измерение и накопление амплитуды эхо 
			COM_CYCLE_OPEN echoes						// начало цикла для эхо
			COM_TIME to_aq_start[i]						// интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
			COM_PH01 ph_180								// установка фазы 180 град. импульса
			COM_RF01 cpmg_rfp_180						// запуск РЧ импульса
			COM_TIME to_echo_aq							// время оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_180[i]						// пауза до следующего РЧ импульса в цикле КПМГ
			COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001
			COM_CYCLE_CLOSE 0, 0, 0						// окончание цикла измерений эхо
			COM_TIME to_aq_start[i]						// интервал tau перед началом обработки 

			// КПМГ. Вычисление амплитуд, формирование буфера передачи данных.
			COM_TIME to_strobe							// длительность строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 0				// сброс счётчика окон
			COM_PROC_CONTROL_STB_1 0, 200, 1			// флаг фиктивного устройства
			COM_TIME to_echoes_proc						// Время рассчета амплитуд КПМГ
			COM_PROC_CONTROL_STB_1 0,CMPG_pkg_num[i], 0	// снятие флага окна АЦП, выполнение Package_003

			// Насыщающая последовательность 90-градусных импульсов [time = t1 + t2 + t3 + t4 + t5 + t6] 
			COM_PH01 ph_90								// установка фазы 90 град. импульса
			var sp=6
			for (var j = sp-1; j >= 0 ; --j) 
			{  
				var interval = t1*Math.pow(2,j)
				COM_TIME interval					// интервал времени 
				COM_RF01 cpmg_rfp_90				// запуск РЧ импульса	
			};
		}

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	CLAY КПМГ. канал cpmg_channel. Короткий КПМГ, с минимальным тау, для измерения глининсто связанного флюида.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		if (clay_activation == 1)						// clay_activation = 0, пропустить CLAY КПМГ
		{
			COM_TIME to_clay							// 
			COM_RF01 cpmg_rfp_90						// запуск РЧ импульса, чтобы оставить только короткую копоненту
			COM_SET_ACC_02 ph_180						// записать фазу ph_180 в регистр аккумуляции фазы 
														//
			COM_CYCLE_OPEN accum_clay					// начало цикла [[2*tau_clay + 1]*echoes_clay + to_clay]*accum_clay
			COM_TIME to_strobe							// длительность строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 1				// установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
			
			// Измерение и накопление шума
			COM_TIME to_aq_start_clay					// интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
			COM_PH_RST 0, 0, 1							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
			COM_TIME to_echo_aq							// время оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_clay_180					// пауза до следующего окна шума в цикле
			COM_PROC_CONTROL_STB_1 0, 2, 0				// останов АЦП, выполнение Package_002

			// Формирование и измерение эхо во внутреннем цикле
			// - формирование 90-град. РЧ импульса
			COM_PH01 ph_90								// установка фазы 90 град. импульса
			COM_TIME red_tau_clay						// интервал времени tau_cpmg1 с поправкой на длительность импульса
			COM_RF01 cpmg_rfp_90						// запуск РЧ импульса

			// - формирование цикла из 180-град. РЧ импульсов, измерение и накопление амплитуды эхо 
			COM_CYCLE_OPEN echoes_clay					// начало цикла для эхо
			COM_TIME to_aq_start_clay					// интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
			COM_ACC_TO_PH 0, 2, 1						// установка фазы 180 град. импульса
			COM_RF01 cpmg_rfp_180						// запуск РЧ импульса
			COM_TIME to_echo_aq							// время оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_clay_180					// пауза до следующего РЧ импульса в цикле КПМГ
			COM_PROC_CONTROL_STB_1 0, 2, 0				// останов АЦП, выполнение Package_002
			COM_CYCLE_CLOSE 0, 0, 0						// окончание цикла измерений эхо
			COM_TIME to_aq_start_clay					// интервал, формирующий паузу ожидания, необходимую для формирования эхо после импульса
														//
			COM_TIME to_clay							// пауза до следующего КПМГ
			COM_ADD_TO_ACC_02 dph						// инкремент фазы
			COM_PROC_CONTROL_STB_2 0, 0, 0				// сброс счётчика окон
														//
			COM_CYCLE_CLOSE 0, 0, 0						// окончание фазового цикла

			// CLAY КПМГ. Вычисление амплитуд, формирование буфера передачи данных.
			COM_TIME to_strobe							// длительность строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 0				// установления флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
			COM_PROC_CONTROL_STB_1 0, 200, 1			// флаг фиктивного устройства для выполнения пакета
			COM_TIME to_clay_echoes_proc				// Время рассчета амплитуд КПМГ и измерения ВДК
			COM_PROC_CONTROL_STB_1 0, ClAY, 0			// снятие флага окна АЦП, выполнение Package_004
		}

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Передача данных.                                  [time = to_strobe + to_data_tx + 1]
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_TIME to_strobe                        // интервал до времени отдыха на разнесение стробов
		COM_PROC_CONTROL_STB_3 0, 0, 0            // установления флага окончания общего окна данных, передача данных в рабочую станцию
		COM_TIME to_data_tx                       // интервал до начала следующей последовательности, в котором выполняется передача данных
		COM_GRADIENT_ON 0, 0, 0                   // выключение постоянного градиента
		COM_TIME 0, 0, 0                          // интервал для команды 1 мкс
		COM_RET 0, 0, 0                           // возврат в начало

#end
// ***********************************************************************************************************


// [Main]

// Описание: Стандартная активация T2, Двойная активация, Активация глин, Активация солид
// Назначение: Активация позволяет получать релаксационный спад (эхо-сигнала) при таком времени ожидания (time waiting) TW, что пластовые флюиды полностью поляризованы,
// и минимальном интервале между эхо (time between echo) Te=2*tau, при котором сводятся к минимумам эффекты диффузии на амплитуду спинового эхо.
// Посмледовательность: [[Aq(noise)]a]n-Tw1-90-tau-180-tau-Aq(echo)-tau-[180-tau-Aq(echo)-tau]a]i-90-t1-90-t2-90-t3-90-t4-90-t5-90-t6-90-Tw2-Send
// Ядро преобразования: Kij=exp(-ti/T2j) 
// Первичная цифровая обработка сигналов:
// - сигналы шума и сигналы спинового эхо измеряются;
// - вычисляются мощностные спектры шума и спиновых эхо;
// - с учётом усреднённого мощностного спектра шума вычисляются амплитуды полезного сигнала спинового эхо
// Контроль обработки данных:
// - сигнал с оконнной функцией
// - амплитудный спектр мощности спектров сигнала и шума
// Вывод данных:
// - амплитуды спинового эхо в последовательности КПМГ

main.name = "2 CPMG with 1 Clay CPMG v.1"
main.author = "КФУ: Скирда В.Д., Александров А.А., Савинков А.В, Дорогиницкий М.М."
main.datetime = "10.10.2017 11:50"
main.description = "Стандартная активация T2, Двойная активация, Активация глин, Активация солид"


// Блок констант
// [Constants]
	var DDS_CLK_FRQ = 250000 													// Тактовая частота DDS (кГц) (константа, прошита в ПЛИС)
	var IF_FRQ = 1250															// Промежуточная частота приемника (кГц) (константа, задана аппаратно)
	var NMR_SAMPLE_FREQ = 5000													// Частота дискретизации (кГц) (константа, задана аппаратно)
	var echoes_max = 500
	var min_tau = 300
	var dead_time = 27

	var n_cmpg_max = 11
	// Таблица TW для измерений T1-T2
	var TWs = new Array(n_cmpg_max)
	TWs[3] = 1280 
	TWs[4] = 640
	TWs[5] = 320
	TWs[6] = 160
	TWs[7] = 80
	TWs[8] = 40
	TWs[9] = 20
	TWs[10] = 10
	// Таблица TD для измерений Ds-T2
	var TEs1 = new Array(n_cmpg_max)
	TEs1[3] = 400
	TEs1[4] = 800
	TEs1[5] = 1600
	TEs1[6] = 3200
	TEs1[7] = 6400
	TEs1[8] = 12800
	TEs1[9] = 25600
	TEs1[10] = 51200
	// Таблица TD для измерений STE-T2
	var TDs = new Array(n_cmpg_max)
	TDs[3] = 10000
	TDs[4] = 40000
	TDs[5] = 70000
	TDs[6] = 100000
	TDs[7] = 130000
	TDs[8] = 170000
	TDs[9] = 200000
	TDs[10] = 230000
	// Таблица TE
	var TEs = new Array(n_cmpg_max)
	
//-----------------------------------------------------------------------------------------------------------
// Блок выбора режима измерений
// [Measure]

	var st_cmpg = 1																// индекс первой КПМГ
	var n_cmpg = 0																// количество КПМГ		
	
	//	0 - включен: 1 КПМГ => 90-TW-90-tau-[180-tau-Aq-tau]n (TW=TW[1]=to_cpmg1; tau=TE[1]=tau_cpmg1; n=Necho)
	//	1 - выключен
	@parameter std_act_enb = { "Стандартная активация", "ON|OFF" }
	std_act_enb.comment = "Включить измерение КПМГ1"
	std_act_enb.uitype = "combobox"
	if (std_act_enb~ == 0) {n_cmpg = 1}
	
	//  0 - выключен; 
	//	1 - включен: 2 КПМГ => 90-TW1-90-tau1-[180-tau1-Aq-tau1]n - 90-TW2-90-tau1-[180-tau1-Aq-tau1]n (TW1=TW[1]=to_cpmg1; TW2=TW[2]=to_cpmg2; tau1=TE[1]=tau_cpmg1; n=Necho)
	//	2 - включен: 2 КПМГ => 90-TW1-90-tau1-[180-tau1-Aq-tau1]n - 90-TW1-90-tau2-[180-tau2-Aq-tau2]n (TW1=TW[1]=to_cpmg1; TW2=TW[2]=to_cpmg1; tau1=TE[1]=tau_cpmg1; tau2=TE[2]=tau_cpmg2; n=Necho)
	@parameter double_act_enb = { "Двойная активация", "OFF|TW|TE" }
	double_act_enb.comment = "Включить измерение КПМГ1-2"
	double_act_enb.uitype = "combobox"
	if (double_act_enb~ > 0) {n_cmpg = 2}
	
	//  0 - выключен; 
	//	1 - включен: КПМГ => 90-[TW-90-tau-[180-tau-Aq-tau]n]m (TW=to_clay; tau=tau_clay; n=echoes_clay; m=4)
	@parameter clay_act_enb = { "Активация Глин", "OFF|ON" }
	clay_act_enb.comment = "Включить измерение ClAY КПМГ"
	clay_act_enb.uitype = "combobox"
	var clay_activation = clay_act_enb~
	
	//  0 - выключен; 
	//	1 - включен: Солид эхо => TW-90-tau-90-tau-Aq (TW=to_cpmg1; tau=tau_solid;)
	@parameter solid_act_enb = { "Активация SOLID", "OFF|ON" }
	solid_act_enb.comment = "Включить измерение солид эхо"
	solid_act_enb.uitype = "combobox"
	var solid_activation = solid_act_enb~
	
	//  0 - выключен; 
	//	1 - включен: 8 КПМГ => [90-TWi-90-tau1-[180-tau1-Aq-tau1]n]m (TWi=TW[i]; tau1=TE[1]=tau_cpmg1; n=Necho; m=8)
	//	2 - включен: 8 КПМГ => [90-TW1-90-taui-[180-taui-Aq-taui]2-[180-tau-Aq-tau]n]m (TW1=TW[1]=to_cpmg1; taui=TE1[i]; tau=TE[1]=tau_cpmg1; n=Necho-2)
	//	2 - включен: 8 КПМГ => [90-TW1-90-tau-90-TDi-90-tau-Aq-tau-[180-tau-Aq-tau]n]m (TW1=TW[1]=to_cpmg1; TDi=TD[i]; tau=TE[1]=tau_cpmg1; n=Necho-2)
	var D2_type = 0
	@parameter D2_act_enb = { "Активация 2D ", "OFF|T1-T2|Ds-T2|STE-T2"}
	D2_act_enb.comment = "Включить измерение КПМГ 1-8"
	D2_act_enb.uitype = "combobox"
	if (D2_act_enb~ > 0) {n_cmpg = 8; st_cmpg = 3}
	if (double_act_enb~ > 0) {st_cmpg = 1}
	
	//	0 - выключен; 1 - включен вывод эхо
	@parameter echo_enb = { "Сигнал эхо", "OFF|ON" }
	echo_enb.comment = "Включить Сигнал Эхо"
	echo_enb.uitype = "combobox"
	
	//	0 - режим однократного запуска; 1 - режим непрерывного запуска
	@parameter infinite_enb = { "Режим", "SCAN|INFINITE" }
	infinite_enb.comment = "Режим SCAN - однократный запуск; Режим INFINITE - непрерывный запуск"
	infinite_enb.uitype = "combobox"
	var mode = infinite_enb~
	
	@section meas = { "Режим измерений" }
	meas.append(std_act_enb)
	meas.append(double_act_enb)
	meas.append(clay_act_enb)
	meas.append(solid_act_enb)
	meas.append(D2_act_enb)
	meas.append(echo_enb)
	meas.append(infinite_enb)
	
//-----------------------------------------------------------------------------------------------------------
// Блок параметров частот
// [Frequencies]
	
	//	Смещение частоты резонанса
	@parameter tx_frq_ofs = { "Частота резонанса", 0, min=-488, max=488, units="кГц" }
	tx_frq_ofs.comment = "Смещение частоты относительно заданной базовой частоты"
	tx_frq_ofs.exec(tx_frq_ofs~ * 4294967296 / DDS_CLK_FRQ)
	//	Смещение опорной частоты передатчика
	@parameter tx_frq2_ofs = { "Опорная частота передатчика", 0, min=-488, max=488, units="кГц" }
	tx_frq2_ofs.comment = "Смещение опорной частоты передачи относительно заданной базовой частоты"
	tx_frq2_ofs.exec(tx_frq2_ofs~ / DDS_CLK_FRQ * 4294967296)
	//	Смещение частоты оцифровки относительно заданной базовой
	var adc_frq_ofs = 0;
	adc_frq_ofs = adc_frq_ofs / DDS_CLK_FRQ * 4294967296;						// Частота АЦП
		
	@section s_freqs = { "Частоты" }
	s_freqs.append(tx_frq_ofs)

//-----------------------------------------------------------------------------------------------------------
// Блок параметров приемника
// [Reciever]
	
	//	Канал измерений
	@parameter channel = { "Номер канала", 1, min=1, max=1 }
	channel.comment = "выбор номера канала измерений (0 - первый канал ЯМР, 1 - второй канал ЯМР, ...)"
	channel.exec(channel~ - 1)
	//	Регулировка емкости варикапов для настройки приемного контура
	@parameter vc_dac = { "Настройка антенны", 2000, min=0, max=5000, units="мВ" }
	vc_dac.comment = "Напряжение на варикапах, мВ"
	vc_dac.exec(vc_dac~ * 65535 / 5000)
	//	Регулировка усиления примника
	@parameter KU = { "Усиление приемника", -10, min=-24, max=0, units="дБ"}
	KU.comment = "Коэффициент усиления приемника"
	KU.exec(- KU~)
	
	@section s_rx = { "Приемник" }
	//s_probes.append(channel)
	s_rx.append(vc_dac)
	s_rx.append(KU)

//-----------------------------------------------------------------------------------------------------------
// Блок длительности РЧ-импульсов
// [RF_pulses]
	
	// Длительность 90-градусного рч-импульса
	@parameter rfp_90 = { "90<sup>0</sup> импульс. Длительность.", 13, min=0, max=1000, units="мкс" }
	rfp_90.comment = "Длительность 90<sup>0</sup> рч-импульса"
	rfp_90.exec(rfp_90~ * 10)																			// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	// Длительность 180-градусного рч-импульса
	@parameter rfp_180 = { "180<sup>0</sup> импульс. Длительность.", 26, min=0, max=1000, units="мкс" }
	rfp_180.comment = "Длительность 180<sup>0</sup> рч-импульса"
	rfp_180.exec(rfp_180~ * 10)																			// *10 т.к. в команде длительность РЧ задается в единицах кратных 0.1 мкс
	// Фаза 90-градусного рч-импульса (0: +x; 90: +y; 180: -x, 270: -y)
	@parameter ph_90 = { "90<sup>0</sup> импульс. Фаза", 0, min=0, max=360, units=" <sup>0</sup>, град." }
	ph_90.comment = "90<sup>0</sup> импульс. Фаза"
	ph_90.exec(ph_90~ * 46603.375)
	// Фаза 180-градусного рч-импульса (0: +x; 90: +y; 180: -x, 270: -y)
	@parameter ph_180 = { "180<sup>0</sup> импульс. Фаза", 90, min=0, max=360, units=" <sup>0</sup>, град." }
	ph_180.comment = "180<sup>0</sup> импульс. Фаза"
	ph_180.exec(ph_180~ * 46603.375)
	
	// Инкремент фазы. Значение инкремента фазы для фазового циклирования
	var dph = 180
	dph = dph * 46603.375; 																				// "град."
	
	@section s_rf_pulses = { "РЧ импульсы" }
	s_rf_pulses.append(rfp_90)
	s_rf_pulses.append(rfp_180)
	//s_rf_pulses.append(ph_90)
	//s_rf_pulses.append(ph_180)

//-----------------------------------------------------------------------------------------------------------
// Блок временных параметров последовательности
// [Intervals]
	
	// "Задержка перед началом измерений, мкс"
	var before_aq = 50000 - 1

	@parameter to_cpmg1 = { "Стандартная активация. TW", 2000, min=50, max=16777, units="мс" }
	to_cpmg1.comment = "Время на восстановление намагниченности после измерений"
	
	@parameter to_cpmg2 = { "Двойная активация. TW2", 50, min=50, max=16777, units="мс" }
	to_cpmg2.comment = "Время на восстановление намагниченности после КПМГ1 (Контраст T1 для активации двойного TW)"
	to_cpmg2.exec(to_cpmg2~ * 1000 - 1)																// *1000 для перевода мс в мкс, минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_clay = { "Активация Глин. TW3", 20, min=10, max=16777, units="мс" }
	to_clay.comment = "Время на восстановление намагниченности глин. (Контраст T1 для активации глин)"
	to_clay.exec(to_clay~ * 1000 - 1)																// *1000 для перевода мс в мкс, минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter tau_cpmg1 = { "Стандартная активация. TAU", 400, min=300, max=16777, units="мкс" }
	tau_cpmg1.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ1"
	
	@parameter tau_cpmg2 = { "Двойная активация. TAU2", 6400, min=300, max=16777, units="мкс" }
	tau_cpmg2.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности КПМГ2. (Контраст T2 для активации двойного TE)"
	
	@parameter tau_clay = { "Активация Глин. TAU3", 300, min=300, max=16777, units="мкс" }
	tau_clay.comment = "Интервал времени между 90<sup>0</sup> и 180<sup>0</sup> импульсами в последовательности CLAY КПМГ "
	
	@parameter tau_solid = { "Активация SOLID. TAU4", 30, min=10, max=16777, units="мкс" }
	tau_solid.comment = "Интервал времени между 90<sup>0</sup> импульсами в последовательности SOLID ECHO "
	
	@parameter to_aq_shift = { "Окно АЦП. Смещение", 20, min=1, max=16777, units="мкс" }
	to_aq_shift.comment = "Смещение окна АЦП от расчетного времени в последовательности КПМГ"
	to_aq_shift.exec(to_aq_shift~ - 1)																// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@parameter to_echo_aq = { "Окно АЦП. Длительность.", 150, min=1, max=16777, units="мкс" }
	to_echo_aq.comment = "Длительность окна АЦП для регистрации сигнала спинового эхо в последовательности КПМГ"
	to_echo_aq.exec(to_echo_aq~ - 1)																// минус 1 мкс, т.к. программатор к каждому интервалу добавляет 1 мкс
	
	@section s_delays = { "Интервалы" }
	s_delays.append(to_cpmg1)
	s_delays.append(to_cpmg2)
	s_delays.append(to_clay)
	s_delays.append(tau_cpmg1)
	s_delays.append(tau_cpmg2)
	s_delays.append(tau_clay)
	s_delays.append(tau_solid)
	//s_delays.append(to_aq_shift)
	s_delays.append(to_echo_aq)
	
	function get_us(x) { return x * 1000 - 1}
	function get_to_aq_start(tau) { return (tau + to_aq_shift~ - (to_echo_aq~ / 2) - 1) }
	function get_to_next_180(tau) { return (tau - to_aq_shift~ - (to_echo_aq~ / 2) - 1) }
	function get_red_tau(tau) { return (tau - rfp_90~ / 2) }

	var to_cpmg_t = new Array(n_cmpg_max)
		
	TWs[1] = to_cpmg1~; TEs[1] = tau_cpmg1~;

	if (double_act_enb~ == 1) {TWs[2] = to_cpmg2~; TEs[2] = tau_cpmg1~}
	if (double_act_enb~ == 2) {TWs[2] = to_cpmg1~; TEs[2] = tau_cpmg2~}	
	
	if (D2_act_enb~ == 1) 
		{for (var i = 3; i < n_cmpg_max; ++i) {TEs[i] = tau_cpmg1~}}
	if (D2_act_enb~ == 2) 
		{
			var to_aq_start_1 = new Array(n_cmpg_max)
			var to_next_180_1 = new Array(n_cmpg_max)
			var red_tau_1 = new Array(n_cmpg_max)
			for (var i = 3; i < n_cmpg_max; ++i) {TWs[i] = TWs[1]; TEs[i] = tau_cpmg1~}
			for (var i = 3; i < n_cmpg_max; ++i) {to_aq_start_1[i] = get_to_aq_start(TEs1[i])}
			for (var i = 3; i < n_cmpg_max; ++i) {to_next_180_1[i] = get_to_next_180(TEs1[i])}
			for (var i = 3; i < n_cmpg_max; ++i) {red_tau_1[i] = get_red_tau(TEs1[i])}
		}
	if (D2_act_enb~ == 3) 
		{for (var i = 3; i < n_cmpg_max; ++i) {TWs[i] = TWs[1]; TEs[i] = tau_cpmg1~}}
	
	// Массив TW
	var to_cpmg = new Array(n_cmpg_max)	
	for (var i = 1; i < n_cmpg_max; ++i) {to_cpmg[i] = get_us(TWs[i])}

	// Массив задержек перед АЦП 
	var to_aq_start = new Array(n_cmpg_max)
	for (var i = 1; i < n_cmpg_max; ++i) {to_aq_start[i] = get_to_aq_start(TEs[i])}				// Задержка перед АЦП в КПМГi, мкс
	// Задержка перед АЦП в CLAY КПМГ, мкс
	var to_aq_start_clay = get_to_aq_start(tau_clay~)											// Задержка перед АЦП в CLAY КПМГ, мкс
	var to_solid_aq_start = rfp_90~ + dead_time 

	// Массив задержек перед 180<sup>0</sup> импульсом
	var to_next_180 = new Array(n_cmpg_max)
	for (var i = 1; i < n_cmpg_max; ++i) {to_next_180[i] = get_to_next_180(TEs[i])}				// Задержка перед 180<sup>0</sup> импульсом КПМГi, мкс
	// "Задержка перед 180<sup>0</sup> импульсом CLAY КПМГ"
	var to_next_clay_180 = get_to_next_180(tau_clay~)											// Задержка перед 180<sup>0</sup> импульсом CLAY КПМГ, мкс

	// Массив: Первое tau, скорректированное
	var red_tau = new Array(n_cmpg_max)
	for (var i = 1; i < n_cmpg_max; ++i) {red_tau[i] = get_red_tau(TEs[i])}						// Первое tau_cpmgi, скорректированное с учетом длительности РЧ импульсов, мкс
	if (D2_act_enb~ == 2) 
		{for (var i = 3; i < n_cmpg_max; ++i) {red_tau[i] = get_red_tau(TEs1[i])}}
	// "Первое tau_clay, скорректированное с учетом длительности РЧ импульсов, мкс"
	var red_tau_clay = get_red_tau(tau_clay~)
	
	// "Интервал повторения, мкс"
	var to_data_tx = 5000000
	// "Интревал для насыщающей последовательности"
	var t1 = 200

//-----------------------------------------------------------------------------------------------------------
// Блок счетчиков
// [Counters]
	
	// Количество окон измерения шума
	@parameter noise = { "КПМГ(1,2). Окон шума", 32, min=1, max=64 }
	noise.comment = "Число окон АЦП для измерения шума"
	// Количество окон измерения эхо
	@parameter Necho = { "КПМГ(1,2). Окон эхо", 2, min=2, max=500 }
	Necho.comment = "Число окон АЦП для измерения сигналов спинового эхо"
	var echoes = new Array(n_cmpg_max)
	for (var i = 1; i < n_cmpg_max; ++i) {echoes[i] = Necho~}
	if (double_act_enb~ == 2) 
	{
		echoes[2] = Math.floor(Necho~ * TEs[1]/TEs[2])
		if (echoes[2] < 2) {echoes[2] = 2}
	}
	// Количество окон измерения эхо для CLAY КПМГ
	@parameter echoes_clay = { "Канал глин. Окон эхо", 20, min=1, max=300 }
	echoes_clay.comment = "Число групп окон АЦП для измерения сигналов спинового эхо"
	// Количество накоплений эхо для CLAY КПМГ
	@parameter accum_clay = { "Канал глин. Накоплений", 2, min=1, max=4 }
	accum_clay.comment = "Число фазовых циклов"
	accum_clay.exec(2 * accum_clay~)
	
	@section s_counters = { "Counters" }
	s_counters.append(noise)
	s_counters.append(Necho)
	s_counters.append(echoes_clay)
	
	
	
// -----------------------------------------------------------------------------------------------------------
// Блок параметров обработки сигнала
// [Processing]

	// "Метод вычитания шума"
	var proc_id = 4;																				// Методы вычитания шума: 0 - не вычитать шум, 1 - вычитать по методу В.Д., 2 - вычитать амплитудные спектры, 3 - выводить только шум, 4 - вычитать интегралы
	// "Коэфициент для первого эхо"
	var k_fe = 1300;																				// Коэфициент для первого эхо
	if (D2_act_enb~ == 3) k_fe = 1000;
	var k_se = 1000;
	// "Время на вычисление"
	var to_echo_proc = 1000;																		// Время на выполнение пакетов инструкций по вычислению амплитуд эхо, мкс
	// "Время на вычисление"
	var to_echoes_proc = new Array(n_cmpg_max)
	for (var i = 1; i < n_cmpg_max; ++i) 
		{to_echoes_proc[i] = to_echo_proc*(echoes[i] + noise~ + 1) + 50000 - 1}						// Время на выполнение пакетов инструкций по вычислению амплитуд эхо КПМГ1 и КПМГ2, мкс
	// "Время на вычисление"
	var to_clay_echoes_proc = to_echo_proc*(echoes_clay~ + 1) + 100000 - 1;							// Время на выполнение пакетов инструкций по вычислению амплитуд эхо CLAY КПМГ, мкс
	var to_solid_proc = 100000 - 1;
	// "Длительность стробов для процессора"
	var to_strobe = 1500 - 1;																		// Длительность стробов для передачи управляющих команд от ПЛИС к процессору, мкс

	// параметры оконных функций во временной области
	// Тип фильтра во врем. обл.
	var win_type = 1;																				// Значение: 0 - прямоугольная функция, 1 - гауссовая форма, 2 - бигауссовая форма
	// Сдвиг фильтра во врем. обл.
	var time_shift = 0 * (NMR_SAMPLE_FREQ + adc_frq_ofs) / 500;										// Сдвиг оконной функции во временной области для обработки сигнала, мкс
	// Ширина фильтра во врем. обл.
	var time_width = 300 * (NMR_SAMPLE_FREQ + adc_frq_ofs) / 500;									// Ширина оконной функции во временной области для обработки, мкс
	// Сдвиг фильтра в част. обл.
	var freq_shift = 250 * 1024 / (NMR_SAMPLE_FREQ + adc_frq_ofs);									// Сдвиг оконной функции в частотной области для обработки сигнала, кГц
	// Ширина фильтра в част. обл.
	var freq_width = 4 * 1024 / (NMR_SAMPLE_FREQ + adc_frq_ofs);									// Ширина оконной функции в частотной области для обработки сигнала, кГц
	
	@parameter emul = { "Эмуляция данных", 1, min=0, max=1 }
	emul.comment = "Эмулировать исходные данные ЯМР ? (Да/Нет)";
	
	@parameter sn = { "Сигнал/шум", 5, min=0 }
	sn.comment = "Отношение сигнал/шум";
	
	@section s_dataorg = { "Источник данных" }
	s_dataorg.append(emul);
	s_dataorg.append(sn);

// -----------------------------------------------------------------------------------------------------------
// Проверяемые после вычислений условия
// Условия накладываются на вычисленные значения параметров перед внесением параметров в интервальную последовательность.
// Если условие не выполняется, то параметры не записываются в интервальную последовательность, и выдаётся соответствующее сообщение.
// -----------------------------------------------------------------------------------------------------------
// [Conditions]

	@condition D1 = { "Проверка устанавливаемой длительности или смещения окна АЦП" }
	D1.msg = "При установленном tau невозможно установить длительность и/или смещение окна АЦП";
	D1.hint = "Проверка устанавливаемой длительности или смещения окна АЦП";
	D1.exec(tau_cpmg1~ + to_aq_shift~ - (to_echo_aq~ /2));

	@condition D3 = { "Проверка ограничения числа окон АЦП" }
	D3.msg = "Слишком  много окон АЦП";
	D3.hint = "Проверка ограничения числа окон АЦП";
	D3.exec(echoes_max - (noise~ + echoes[1]));

// -----------------------------------------------------------------------------------------------------------
// Блок правил расчёта временных отсчётов для принимаемых и сохраняемых массивов амплитуд
// При расчёте временных отсчётов по указанной в описании формуле индекс инкрементно увеличивается на 1.
//[Arguments]

	function cpmg_X(N, tau)
	{
		var pts = new Array(N);
		for (var i = 0; i < N; ++i) { pts[i] = 2*tau * (i + 1) / 1000 };
		return pts;
	}

	function D2_X(N, tau, k)
	{
		var pts = new Array(N);
		for (var i = 0; i < N; ++i) 
			{ 
				var tau1 = TEs[k];
				if (D2_act_enb~ == 2) tau1 = TEs1[k];
				if(i < 2) {pts[i] = 2*tau1 * (i + 1) / 1000}
				else {pts[i] = (4*tau1 + 2*tau * (i - 1)) / 1000}
			};
		return pts;
	}
	
	@argument cpmg1_X = { "Временные отсчёты эхо в последовательности КПМГ1" }
	cpmg1_X.units = "ms";
	cpmg1_X.size = echoes[1];
	cpmg1_X.points = cpmg_X(cpmg1_X.size, TEs[1]);
	
	@argument cpmg2_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg2_X.units = "ms";
	cpmg2_X.size = echoes[2];
	cpmg2_X.points = cpmg_X(cpmg2_X.size, TEs[2]);

	@argument cpmg3_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg3_X.units = "ms";
	cpmg3_X.size = echoes[3];
	cpmg3_X.points = D2_X(cpmg3_X.size, TEs[3],3);

	@argument cpmg4_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg4_X.units = "ms";
	cpmg4_X.size = echoes[4];
	cpmg4_X.points = D2_X(cpmg4_X.size, TEs[4],4);

	@argument cpmg5_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg5_X.units = "ms";
	cpmg5_X.size = echoes[5];
	cpmg5_X.points = D2_X(cpmg5_X.size, TEs[5],5);

	@argument cpmg6_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg6_X.units = "ms";
	cpmg6_X.size = echoes[6];
	cpmg6_X.points = D2_X(cpmg6_X.size, TEs[6],6);

	@argument cpmg7_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg7_X.units = "ms";
	cpmg7_X.size = echoes[7];
	cpmg7_X.points = D2_X(cpmg7_X.size, TEs[7],7);

	@argument cpmg8_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg8_X.units = "ms";
	cpmg8_X.size = echoes[8];
	cpmg8_X.points = D2_X(cpmg8_X.size, TEs[8],8);

	@argument cpmg9_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg9_X.units = "ms";
	cpmg9_X.size = echoes[9];
	cpmg9_X.points = D2_X(cpmg9_X.size, TEs[9],9);

	@argument cpmg10_X = { "Временные отсчёты эхо в последовательности КПМГ2" }
	cpmg10_X.units = "ms";
	cpmg10_X.size = echoes[10];
	cpmg10_X.points = D2_X(cpmg10_X.size, TEs[10],10);
	
	@argument clay_X = { "Временные отсчёты эхо в последовательности CLAY КПМГ" }
	clay_X.units = "ms";
	clay_X.size = echoes_clay~;
	clay_X.points = cpmg_X(clay_X.size, tau_clay~);

	@argument solid_X = { "Временные отсчёты эхо в последовательности SOLID ECHO" }
	solid_X.units = "ms";
	solid_X.size = 1;
	solid_X.points = [2*tau_solid~/1000];


// ************************** Пакеты инструкций **************************************************************
// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_001]
	@proc STD_ECHO = { "ECHO" }
	#begin(STD_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, noise, 1, sn, 1, k_fe)                                  
		INS_NO_OP(0, 0)
	#end
	 
	// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_002]
	@proc CLAY_ECHO = { "CLAY ECHO" }
	#begin(CLAY_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, 1, echoes_clay, sn, 0, k_fe)                                  
		INS_NO_OP(0, 0)
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Накопление сигнала шума или спиновго эхо в ячейку памяти по адресу, определённому по счетчику числа окон STB1
	// [Package_002a]
	@proc SOLID_ECHO = { "SOLID ECHO" }
	#begin(SOLID_ECHO)
		INS_NS_SGN_UPP_PRE3(6, 0, emul, 0, 1, sn, 0, k_se)                                  
		INS_NO_OP(0, 0)
	#end
	
	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ1, формирование массива для передачи данных
	// [Package_003]
	@proc CPMG1 = { "Decay calc" }
	#begin(CPMG1)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[1], 1, proc_id, echo_enb, echo_enb, 1, 1, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ2, формирование массива для передачи данных
	// [Package_004]
	@proc CPMG2 = { "Decay calc" }
	#begin(CPMG2)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[2], 1, proc_id, echo_enb, echo_enb, 1, 2, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end	

// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ3, формирование массива для передачи данных
	// [Package_005]
	@proc CPMG3 = { "Decay calc" }
	#begin(CPMG3)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[3], 1, proc_id, echo_enb, echo_enb, 1, 3, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ4, формирование массива для передачи данных
	// [Package_006]
	@proc CPMG4 = { "Decay calc" }
	#begin(CPMG4)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[4], 1, proc_id, echo_enb, echo_enb, 1, 4, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ5, формирование массива для передачи данных
	// [Package_007]
	@proc CPMG5 = { "Decay calc" }
	#begin(CPMG5)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[5], 1, proc_id, echo_enb, echo_enb, 1, 5, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ6, формирование массива для передачи данных
	// [Package_008]
	@proc CPMG6 = { "Decay calc" }
	#begin(CPMG6)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[6], 1, proc_id, echo_enb, echo_enb, 1, 6, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ7, формирование массива для передачи данных
	// [Package_009]
	@proc CPMG7 = { "Decay calc" }
	#begin(CPMG7)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[7], 1, proc_id, echo_enb, echo_enb, 1, 7, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ8, формирование массива для передачи данных
	// [Package_010]
	@proc CPMG8 = { "Decay calc" }
	#begin(CPMG8)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[8], 1, proc_id, echo_enb, echo_enb, 1, 8, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ9, формирование массива для передачи данных
	// [Package_011]
	@proc CPMG9 = { "Decay calc" }
	#begin(CPMG9)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[9], 1, proc_id, echo_enb, echo_enb, 1, 9, 1)							// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд КПМГ10, формирование массива для передачи данных
	// [Package_012]
	@proc CPMG10 = { "Decay calc" }
	#begin(CPMG10)
		//INS_WIN_TIME(3, 0, win_type, time_shift, time_width)
		//INS_WIN_FREQ(3, 0, win_type, freq_shift, freq_width)
		INS_SGN_PROC3(9, 0, noise, echoes[10], 1, proc_id, echo_enb, echo_enb, 1, 10, 1)						// вычисление амплитуды
		INS_CLEAR_HX(2, 0, 0, echoes_max)                                                                       // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                         // очистка указателя стека                                   
		INS_NO_OP(0, 0)  
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд ClAY КПМГ, формирование массива для передачи данных
	// [Package_013]
	@proc ClAY = { "Clay decay calc" }
	#begin(ClAY)
		INS_SGN_PROC3(9, 0, 1, echoes_clay, accum_clay, proc_id, echo_enb, echo_enb, 0, 11, 1)					 // вычисление амплитуды                                          
		INS_CLEAR_HX(2, 0, 0, 500)                                                                               // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                          // очистка указателя стека                                       
		INS_NO_OP(0, 0)           
	#end

	// -----------------------------------------------------------------------------------------------------------
	// Вычисление амплитуд SOLID ECHO, формирование массива для передачи данных
	// [Package_014]
	@proc SOLID = { "Solid Amp calc" }
	#begin(SOLID)
		INS_SGN_PROC3(9, 0, 0, 1, 1, 0, echo_enb, echo_enb, 0, 12, 1)											 // вычисление амплитуды                                          
		INS_CLEAR_HX(2, 0, 0, 500)                                                                               // очистка массивов контейнера data_heapX
		INS_CL_ST(0, 0)                                                                                          // очистка указателя стека                                       
		INS_NO_OP(0, 0)           
	#end
	
	// Массив номеров пакетов
	var CMPG_pkg_num = new Array(n_cmpg_max)
	CMPG_pkg_num[1] = CPMG1.id
	CMPG_pkg_num[2] = CPMG2.id
	CMPG_pkg_num[3] = CPMG3.id
	CMPG_pkg_num[4] = CPMG4.id
	CMPG_pkg_num[5] = CPMG5.id
	CMPG_pkg_num[6] = CPMG6.id
	CMPG_pkg_num[7] = CPMG7.id
	CMPG_pkg_num[8] = CPMG8.id
	CMPG_pkg_num[9] = CPMG9.id
	CMPG_pkg_num[10] = CPMG10.id

// ***********************************************************************************************************


// ***********************************************************************************************************
// Интервальная программа
// Структура: 
// (имя команды), (первый байт команды), (второй байт команды), (третий байт команды) – явное задание параметров команды 
// (имя команды), (имя параметра) – неявное, настраиваемое задание параметров команды; 
// -----------------------------------------------------------------------------------------------------------

// [Commands]
// Инициализация и задержка на передачу данных
// 12 * 0,4 мкс = 4,8 мкс + delay_before_rf_pulses
@comm fpga = { "FPGA program" }
#begin(fpga)
	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Инициализация канала channel
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************
				
		COM_TIME 0, 1, 255          				// интервал для SPI
		COM_SWITCH_FRQ channel					// установка базовых частот канала ЯМР
		COM_OFS01 tx_frq_ofs						// установка гетеродинной частоты передатчика
		COM_OFS02 tx_frq2_ofs						// установка вспомогательной частоты передатчика 
		COM_OFS03 tx_frq_ofs						// установка гетеродинной частоты приёмника
		COM_OFS05 adc_frq_ofs						// установка частоты дискретизации АЦП относительно базовой частоты
		COM_PH_RST 0, 0, 0							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
		COM_SET_VC_DAC_2 vc_dac						// установка напряжения на варикапах
		COM_TIME 0, 1, 255          				// интервал для SPI
		COM_SET_GAIN_1 KU							// установка коэффициента ослбления приемника
		COM_GRADIENT_ON 0, 0, 1						// включение градиента
		
		COM_TIME before_aq          				// Задержка на установление режимов работы устройств
		COM_PROC_CONTROL_STB_3 0, 0, 1				// установка флага начала общего окна данных

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Стандартная (КПМГ)(n_cmpg=1) и Двойная (2 КПМГ)(n_cmpg=1) активация. канал channel.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************
		
		for (var i = st_cmpg; i < st_cmpg+n_cmpg; ++i)	// std_activation = 0, пропустить КПМГ 1,2
		{			
			COM_TIME to_strobe							// интервал строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 1				// установка флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
			
			// Измерение шума во внутреннем цикле 
			COM_CYCLE_OPEN noise						// начало цикла для измерений шума
			COM_TIME to_echo_aq							// интервал оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME (2*min_tau)						// интервал  до следующего окна шума в цикле
			COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001
			COM_CYCLE_CLOSE 0, 0, 0						// окончание цикла измерений шума
			
			// Насыщающая последовательность 90-градусных импульсов 
			COM_PH01 ph_90								// установка фазы +x рч-импульса
			var sp=6
			for (var j = sp-1; j >= 0 ; --j) 
			{  
				var interval = t1*Math.pow(2,j)
				COM_TIME interval						// интервал времени
				COM_RF01 rfp_90							// запуск pi/2 рч-импульса	
			};
			COM_TIME to_cpmg[i]							// интервал TWi (востановление намагниченности)
			
			// Формирование и измерение эхо во внутреннем цикле
			// - формирование 90-град. рч-импульса
			COM_TIME red_tau[i]							// интервал времени tau_cpmg1 с поправкой на длительность импульса
			COM_PH_RST 0, 0, 1							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
			COM_PH01 ph_90								// установка фазы +x рч-импульса
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса
			
			var N = echoes[i]
			if (i > 2 & D2_act_enb~ == 2)				// - формирование и измерение 2х первых эхо, для Ds-T2
			{ 
				N = echoes[i] - 2
				COM_TIME to_aq_start_1[i]					// интервал перед формированием эхо после импульса
				COM_PH01 ph_180								// установка фазы +y рч-импульса
				COM_RF01 rfp_180							// запуск pi рч-импульса
				COM_TIME to_echo_aq							// интервал оцифровки сигнала
				COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
				COM_TIME to_next_180_1[i]					// интервал  до следующего рч-импульса в цикле КПМГ
				COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001

				COM_TIME to_aq_start_1[i]					// интервал перед формированием эхо после импульса
				COM_PH01 ph_180								// установка фазы +y рч-импульса
				COM_RF01 rfp_180							// запуск pi рч-импульса
				COM_TIME to_echo_aq							// интервал оцифровки сигнала
				COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
				COM_TIME to_next_180[i]						// интервал  до следующего рч-импульса в цикле КПМГ
				COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001
			}

			if (i > 2 & D2_act_enb~ == 3)				// - формирование и измерение стимулированного эхо, для STE-Ds-T2
			{ 
				N = echoes[i] - 1
				COM_TIME TDs[i]
				COM_PH01 ph_180								// установка фазы +y рч-импульса
				COM_RF01 rfp_90								// запуск pi/2 рч-импульса
				COM_TIME to_aq_start[i]						// интервал перед формированием эхо после импульса
				COM_RF01 rfp_90								// запуск pi/2 рч-импульса
				COM_TIME to_echo_aq							// интервал оцифровки сигнала
				COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
				COM_TIME to_next_180[i]						// интервал  до следующего рч-импульса в цикле КПМГ
				COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001
			}

			// - формирование цикла из 180-град. РЧ импульсов, измерение и накопление амплитуды эхо 
			COM_CYCLE_OPEN N							// начало цикла для эхо
			COM_TIME to_aq_start[i]						// интервал перед формированием эхо после импульса
			COM_PH01 ph_180								// установка фазы +y рч-импульса
			COM_RF01 rfp_180							// запуск pi рч-импульса
			COM_TIME to_echo_aq							// интервал оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_180[i]						// интервал  до следующего рч-импульса в цикле КПМГ
			COM_PROC_CONTROL_STB_1 0, 1, 0				// останов АЦП, выполнение Package_001
			COM_CYCLE_CLOSE 0, 0, 0						// окончание цикла измерений эхо
			COM_TIME to_aq_start[i]						// интервал tau перед началом обработки 

			// КПМГ. Вычисление амплитуд, формирование буфера передачи данных.
			COM_TIME to_strobe							// интервал строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 0				// сброс счётчика окон
			COM_PROC_CONTROL_STB_1 0, 200, 1			// установка флага фиктивного устройства
			COM_TIME to_echoes_proc[i]					// интервал рассчета амплитуд КПМГ
			COM_PROC_CONTROL_STB_1 0,CMPG_pkg_num[i], 0	// снятие флага окна АЦП, выполнение пакета № i
		}

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	CLAY КПМГ. канал channel. Короткий КПМГ, с минимальным тау, для измерения глининсто-связанного флюида.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		if (clay_activation == 1)						// clay_activation = 0, пропустить CLAY КПМГ
		{
			COM_TIME to_strobe							
			COM_GRADIENT_ON 0, 0, 1						// включение градиента
			
			COM_TIME to_clay							// 
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса, чтобы оставить только короткую копоненту
			COM_SET_ACC_02 ph_180						// записать фазу ph_180 в регистр аккумуляции фазы 
														//
			COM_CYCLE_OPEN accum_clay					// начало цикла
			COM_TIME to_strobe							// интервал строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 1				// установка флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
			
			// Измерение шума во внутреннем цикле 
			COM_TIME to_echo_aq							// интервал оцифровки сигнала
			COM_PH_RST 0, 0, 1							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME (2*min_tau)						// интервал  до следующего окна шума в цикле
			COM_PROC_CONTROL_STB_1 0, 2, 0				// останов АЦП, выполнение Package_002
			
			// Формирование и измерение эхо во внутреннем цикле
			// - формирование 90-град. рч-импульса
			COM_PH01 ph_90								// установка фазы +x рч-импульса
			COM_TIME red_tau_clay						// интервал времени tau_cpmg1 с поправкой на длительность импульса
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса

			// - формирование цикла из 180-град. РЧ импульсов, измерение и накопление амплитуды эхо 
			COM_CYCLE_OPEN echoes_clay					// начало цикла для эхо
			COM_TIME to_aq_start_clay					// интервал перед формированием эхо после импульса
			COM_ACC_TO_PH 0, 2, 1						// установка фазы +y рч-импульса
			COM_RF01 rfp_180							// запуск pi рч-импульса
			COM_TIME to_echo_aq							// интервал оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_next_clay_180					// интервал  до следующего рч-импульса в цикле КПМГ
			COM_PROC_CONTROL_STB_1 0, 2, 0				// останов АЦП, выполнение Package_002
			COM_CYCLE_CLOSE 0, 0, 0						// окончание цикла измерений эхо
			COM_TIME to_aq_start_clay					// интервал перед формированием эхо после импульса
														//
			COM_TIME to_clay							// интервал  до следующего CLAY КПМГ
			COM_ADD_TO_ACC_02 dph						// инкремент фазы
			COM_PROC_CONTROL_STB_2 0, 0, 0				// сброс счётчика окон
														//
			COM_CYCLE_CLOSE 0, 0, 0						// окончание фазового цикла

			// CLAY КПМГ. Вычисление амплитуд, формирование буфера передачи данных.
			COM_TIME to_strobe							// интервал строба идентификации пакета
			COM_GRADIENT_ON 0, 0, 0						// выключение градиента
			COM_PROC_CONTROL_STB_2 0, 0, 0				// установка флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
			COM_PROC_CONTROL_STB_1 0, 200, 1			// установка флага фиктивного устройства для выполнения пакета
			COM_TIME to_clay_echoes_proc				// интервал рассчета амплитуд КПМГ
			COM_PROC_CONTROL_STB_1 0, ClAY, 0			// снятие флага окна АЦП, выполнение Package № CLAY
		}

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	SOLID ECHO. канал channel. Короткий КПМГ, с минимальным тау, для измерения глининсто-связанного флюида.
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		if (solid_activation == 1)						// solid_act_enb = 0, пропустить SOLID ECHO
		{
			COM_TIME to_strobe							// интервал строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 1				// установка флага начала окна данных прибора ЯМР, включение счётчика окон АЦП
			
			// Насыщающая последовательность 90-градусных импульсов 
			COM_PH01 ph_90								// установка фазы +x рч-импульса
			var sp=6
			for (var j = sp-1; j >= 0 ; --j) 
			{  
				var interval = t1*Math.pow(2,j)
				COM_TIME interval						// интервал времени
				COM_RF01 rfp_90							// запуск pi/2 рч-импульса	
			};
			COM_TIME to_cpmg[1]							// интервал TW1 (востановление намагниченности)

			COM_TIME tau_solid							// интервал времени tau_cpmg1 с поправкой на длительность импульса
			COM_PH_RST 0, 0, 1							// синхронизация фаз всех РЧ каналов для возможности накопления на осциллографе
			COM_PH01 ph_90								// установка фазы +x рч-импульса
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса

			COM_TIME to_solid_aq_start					// интервал перед формированием эхо после импульса
			COM_PH01 ph_180								// установка фазы +y рч-импульса
			COM_RF01 rfp_90								// запуск pi/2 рч-импульса
			COM_TIME to_echo_aq							// интервал оцифровки сигнала
			COM_PROC_CONTROL_STB_1 0, 254, 1			// запуск АЦП
			COM_TIME to_strobe							// интервал 
			COM_PROC_CONTROL_STB_1 0, 3, 0				// останов АЦП, выполнение Package_001

			// Вычисление амплитуд, формирование буфера передачи данных.
			COM_TIME to_strobe							// интервал строба идентификации пакета
			COM_PROC_CONTROL_STB_2 0, 0, 0				// сброс счётчика окон
			COM_PROC_CONTROL_STB_1 0, 200, 1			// установка флага фиктивного устройства
			COM_TIME to_solid_proc						// интервал рассчета амплитуд КПМГ
			COM_PROC_CONTROL_STB_1 0,SOLID, 0			// снятие флага окна АЦП, выполнение пакета № i
		}

	// ***********************************************************************************************************
	// ***********************************************************************************************************
	//	Передача данных.                                  [time = to_strobe + to_data_tx + 1]
	// -----------------------------------------------------------------------------------------------------------
	// ***********************************************************************************************************

		COM_TIME to_strobe								// интервал до времени отдыха на разнесение стробов
		COM_PROC_CONTROL_STB_3 0, 0, 0					// установка флага окончания общего окна данных, передача данных в рабочую станцию
		COM_TIME to_data_tx								// интервал до начала следующей последовательности, в котором выполняется передача данных
		COM_GRADIENT_ON 0, 0, 0							// выключение градиента
		COM_TIME 0, 0, 0								// интервал для команды 1 мкс
		if (mode == 0)									 
		{
			COM_STOP 0, 0, 0
		}												// конец последовательности
		if (mode == 1) 
		{
			COM_RET 0, 0, 0
		}												// возврат в начало

#end
// ***********************************************************************************************************

